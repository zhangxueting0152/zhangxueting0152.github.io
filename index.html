<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-渲染机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/11/渲染机制/" class="article-date">
  <time datetime="2019-01-11T03:02:23.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/11/渲染机制/">渲染机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器的渲染过程："><a href="#浏览器的渲染过程：" class="headerlink" title="浏览器的渲染过程："></a>浏览器的渲染过程：</h2><p><img src="/2019/01/11/渲染机制/浏览器渲染过程.png" alt="浏览器渲染过程"></p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>
</ol>
<h2 id="Load-和-DOMContentLoaded："><a href="#Load-和-DOMContentLoaded：" class="headerlink" title="Load 和 DOMContentLoaded："></a>Load 和 DOMContentLoaded：</h2><p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。<br>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待CSS，JS，图片加载。</p>
<h2 id="图层："><a href="#图层：" class="headerlink" title="图层："></a>图层：</h2><p>可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。<br>不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。<br>生成新图层的属性：</p>
<ol>
<li>3D 变换：translate3d、translateZ</li>
<li>will-change<br>例如想通知浏览器会发生一个transform方面的变化，可以这样写：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">	will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐的做法是当一个元素或属性发生变化时打开will-change，变化完成之后关闭它。</p>
<ol start="3">
<li>video、iframe 标签</li>
<li>通过动画实现的 opacity 动画转换</li>
<li>position: fixed</li>
</ol>
<h2 id="重绘（Repaint）和回流（Reflow）："><a href="#重绘（Repaint）和回流（Reflow）：" class="headerlink" title="重绘（Repaint）和回流（Reflow）："></a>重绘（Repaint）和回流（Reflow）：</h2><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘。<br>回流是布局或者几何属性需要改变就称为回流。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的。<br>例如，改变 window 大小，改变字体，添加或删除样式，定位或者浮动都会导致性能问题。</p>
<p>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。<br>会依次判断是否有 resize 或者 scroll，是否触发了 media query，更新动画，全屏操作事件，执行 requestAnimationFrame，执行 IntersectionObserver等等，然后更新界面。</p>
<p>减少重绘和回流的方法：</p>
<ol>
<li><p>使用 translate 替代 top</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-$(<span class="string">'.x'</span>).css(<span class="string">'top'</span>, <span class="string">'200px'</span>)</span><br><span class="line">+$(<span class="string">'.x'</span>).css(<span class="string">'translateY'</span>, <span class="string">'translateY(200px)'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）。</p>
</li>
<li>把 DOM 离线后（例如将DOM设置为display:none）再修改，改完后再将其显示出来。</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。</li>
<li>不要使用table，因为可能很小的一个小改动会造成整个 table 的重新布局。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/11/渲染机制/" data-id="cjqrhd64o000jjotexkl3an0u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/10/存储/" class="article-date">
  <time datetime="2019-01-10T10:34:46.906Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/存储/">存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cookie，localStorage，sessionStorage，indexDB<br>Web Storage（Local Storage和Session Storage）使用简单字符串键值对在本地存储数据，方便灵活，但是不适于大量结构化数据存储。<br>indexDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。<br>对于简单的数据，应该使用localstorage，但当存储大量数据时，indexDB会更适合，indexDB能提供更为复杂的查询数据的方式。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie由服务器生成，可以设置过期时间；<br>数据存储大小是4k；<br>参与与服务端通信时，每次都会携带在header中，对于请求性能影响。<br>不建议用于存储。<br>对于cookie,需要注意安全问题：<br>1.value属性用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识；<br>2.http-only属性：若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。<br>从而减少XSS攻击。<br>3.secure属性：设置是否只能通过https来传递此条cookie；<br>4.same-site：规定浏览器不能在跨域请求中携带cookie，减少CSRF攻击。</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage除非被清理，否则一直存在；<br>数据存储大小是5M；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">https://www.cnblogs.com/st-leslie/p/5617130.html</a><br>localStorage主要是用来作为本地存储来使用的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.优点：<br>localStorage拓展了cookie的4K限制，解决了cookie存储空间不足的问题，localStorage中一般浏览器支持的是5M大小。<br>localStorage可以将第一次请求的数据直接存储到本地。<br>2.局限：<br>localStorage的值类型限定为string类型，所以对我们JSON对象类型需要一些转换。<br>localStorage在浏览器的隐私模式下面是不可读取的。<br>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。<br>localStorage不能被爬虫抓取到。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>setItem(),getItem(),clear(),removeItem(),storage.keyName = value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!window.localStorage)&#123;</span><br><span class="line">    alert(<span class="string">"浏览器不支持localstorage"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    var storage = window.localStorage;</span><br><span class="line">    var data = &#123;</span><br><span class="line">    	name: <span class="string">'zxt'</span>,</span><br><span class="line">    	age: 23,</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"a"</span>,4);</span><br><span class="line">    storage.setItem(<span class="string">"b"</span>,5);</span><br><span class="line">    storage.setItem(<span class="string">"data"</span>,JSON.stringify(data));</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 4</span><br><span class="line">    storage.a = 7;// 修改值</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 7</span><br><span class="line">    storage.removeItem(<span class="string">"a"</span>);</span><br><span class="line">    // storage.clear();// 清除storage的所有内容</span><br><span class="line">    console.log(storage.key(0));// b 输入索引即可获取对应的键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage页面关闭就被清理；<br>数据存储大小是5M；<br>不参与与服务端通信。</p>
<p>localStorage与sessionStorage的区别是localStorage属于永久性存储，而sessionStorage属于当会话结束(例如页面关闭)的时候，sessionStorage中的键值对会被清空.</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>sessionStorage除非被清理，否则一直存在；<br>数据存储大小是无限的；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphinX/p/3415761.html</a><br>indexedDB是一个非关系型数据库系统,然而它是使用JavaScript对象,而不是列数固定的表格来存储数据的。<br>indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可s以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。</p>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>待学习~<br>站渐进式增强体验(PWA)改造：Service Worker 应用<br>Service Worker 最主要的特点是：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</p>
<p>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。<br><a href="http://lzw.me/a/pwa-service-worker.html" target="_blank" rel="noopener">http://lzw.me/a/pwa-service-worker.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/存储/" data-id="cjqrhd64j000ejote57a8m5a8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-跨域请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/跨域请求/" class="article-date">
  <time datetime="2019-01-09T02:53:35.680Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/跨域请求/">js跨域请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p>同源：是指协议，域名和端口相同。<br>同源策略：基于安全考虑，当前域不能访问其他域的东西。<br>如果a的URL是<a href="http://www.a.com:8080/test1/a.js" target="_blank" rel="noopener">http://www.a.com:8080/test1/a.js</a> ，那么<br>1.b的url是<a href="https://www.a.com:8080/test1/a.js" target="_blank" rel="noopener">https://www.a.com:8080/test1/a.js</a> 时，a和b不同源，因为协议不同；<br>2.b的url是<a href="http://www.b.com:8080/test1/a.js" target="_blank" rel="noopener">http://www.b.com:8080/test1/a.js</a> 时，a和b不同源，因为域名不同；<br>3.b的url是<a href="http://www.a.com:3000/test1/a.js" target="_blank" rel="noopener">http://www.a.com:3000/test1/a.js</a> 时，a和b不同源，因为端口不同；<br>4.b的url是<a href="http://www.a.com:8080/test2/a.js" target="_blank" rel="noopener">http://www.a.com:8080/test2/a.js</a> 时，a和b同源，是同意域名下的不同文件夹；<br>5.<a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 和<a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a> 是同源的，在同一域名下。</p>
<h2 id="跨域请求方式"><a href="#跨域请求方式" class="headerlink" title="跨域请求方式"></a>跨域请求方式</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>原理就是动态创建script标签，然后利用script标签美欧跨域限制的漏洞。<br>JSONP使用简单，但是只限于get请求。<br>原理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> callback(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>开发中，可以这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mydiv"</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		var myBtn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">		myBtn.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">			var script = document.createElement(<span class="string">"script"</span>);</span><br><span class="line">			script.src = <span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>;</span><br><span class="line">			script.type = <span class="string">"text/javascript"</span>;  </span><br><span class="line">			document.body.insertBefore(script, document.body.firstChild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> callback(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-document-domain-iframe"><a href="#2-document-domain-iframe" class="headerlink" title="2.document.domain + iframe"></a>2.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。<br>只需要给页面添加document.domain=”test.com”表示二级域名都相同就可以实现跨域。<br>我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。<br>页面<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"http://example.com/b.html"</span> id=<span class="string">"iframe"</span> onload=<span class="string">"test()"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain = <span class="string">'example.com'</span>;// 设置成主域</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">	alert(document.getElementById(<span class="string">'iframe'</span>).contentWindow);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.domain = <span class="string">'example.com'</span>;// 使得这个页面于主页面的document.domain相同</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过js访问到iframe中的各种属性和对象了。</p>
<h3 id="3-window-name-iframe"><a href="#3-window-name-iframe" class="headerlink" title="3.window.name + iframe"></a>3.window.name + iframe</h3><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>原理就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。<br>页面<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"http://www.source.com/data.html"</span> id=<span class="string">"proxy"</span> onload=<span class="string">"getData()"</span> style=<span class="string">"display: none"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// iframe载入data.html页面后会执行此函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">	var iframe= document.getElementById(<span class="string">'proxy'</span>);</span><br><span class="line">	iframe.src = <span class="string">'b.html'</span>;// 这里的b.html是任意一个页面，只要和a.html同源即可，便可以保证a.html访问到iframe里的东西。设置成‘’也可以。</span><br><span class="line">	iframe.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		var data = iframe.contentWindow.name;// 获取iframe里的window.name，里面存放着设置的数据。</span><br><span class="line">		alert(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://www.source.com/data.html" target="_blank" rel="noopener">http://www.source.com/data.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.name = <span class="string">'要传给页面a.html的数据，所有可以转化成字符串的数据都可以放在这里'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-HTML5中window-postMessage方法"><a href="#4-HTML5中window-postMessage方法" class="headerlink" title="4.HTML5中window.postMessage方法"></a>4.HTML5中window.postMessage方法</h3><p>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</p>
<p>页面<a href="http://a.com/a.html" target="_blank" rel="noopener">http://a.com/a.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"http://b.com/b.html"</span> id=<span class="string">"iframe"</span> onload=<span class="string">"onLoad()"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">onLoad</span></span>() &#123;</span><br><span class="line">	var iframe= document.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">	var targetOrigin = <span class="string">'*'</span>;</span><br><span class="line">	iframe.contentWindow.postMessage(<span class="string">'我是来自页面a的消息!'</span>, targetOrigin); </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://b.com/b.html" target="_blank" rel="noopener">http://b.com/b.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onmessage = <span class="keyword">function</span>(e) &#123;// 注册message事件来接收消息</span><br><span class="line">	e = e || event;// 事件对象</span><br><span class="line">	alert(e.data);</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">window.addEventListener(<span class="string">'message'</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">	var origin = event.origin || event.originalEvent.origin；</span><br><span class="line">    // 通过origin属性判断消息来源地址</span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="string">'http://a.com'</span>) &#123;</span><br><span class="line">        alert(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>运行a页面后，会弹出”我是来自页面a的消息!”的alert框。</p>
<h3 id="5-web-sockets"><a href="#5-web-sockets" class="headerlink" title="5.web sockets"></a>5.web sockets</h3><p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。<br>同源策略对web sockets不适用。<br>原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。<br>只有在支持web socket协议的服务器上才能正常工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var socket= new WebSocket(<span class="string">'ws://www.baidu.com'</span>);// http-&gt;ws; https-&gt;wss</span><br><span class="line">socket.send(<span class="string">"hello WebSocket"</span>);</span><br><span class="line">socket.onMessage = <span class="keyword">function</span>(event) &#123;</span><br><span class="line">	var data = event.data;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6-CORS"><a href="#6-CORS" class="headerlink" title="6.CORS"></a>6.CORS</h3><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>是 JSONP 模式的现代版。CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。<br>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compatibleCORS(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    <span class="keyword">if</span> (xhr.withCredentials !== undefined) &#123;</span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeof XDomainRequest !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        //XDomainRequest是IE用于支持CORS请求的对象</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> xhr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var xhr = compatibleCORS(<span class="string">'GET'</span>, <span class="string">"your url"</span>);</span><br><span class="line"><span class="keyword">if</span> (!xhr) &#123;</span><br><span class="line">    throw new Erorr(<span class="string">"CORS不被支持"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端:<br>通过设置http响应头Access-Control-Allow-Origin: <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> (这里可以是* , 代表接所有网站都可以访问资源)。</p>
<p>下面这段代码还不理解是干嘛的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    // 头信息配置</span><br><span class="line">&#125;).<span class="keyword">then</span>(() =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-location-hash-iframe"><a href="#7-location-hash-iframe" class="headerlink" title="7.location.hash + iframe"></a>7.location.hash + iframe</h3><p>利用 location.hash 来传值。 缺点：数据直接暴露在url中，大小、类型都有限制。<br>例1：<br>原理是利用location.hash来进行传值。<br>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。<br>1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面<br>2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据<br>3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值<br>注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe<br>a.com下的文件cs1.html文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">startRequest</span></span>()&#123;</span><br><span class="line">    var ifr = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifr.src = <span class="string">'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'</span>;</span><br><span class="line">    document.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">checkHash</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var data = location.hash ? location.hash.substring(1) : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (console.log) &#123;</span><br><span class="line">            console.log(<span class="string">'Now the data is '</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, 2000);</span><br></pre></td></tr></table></figure></p>
<p>cnblogs.com域名下的cs2.html:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//模拟一个简单的参数处理操作</span><br><span class="line">switch(location.hash)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramdo'</span>:</span><br><span class="line">        callBack();</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramset'</span>:</span><br><span class="line">        //<span class="keyword">do</span> something……</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">callBack</span></span>()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        parent.location.hash = <span class="string">'somedata'</span>;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        // ie、chrome的安全机制无法修改parent.location.hash，</span><br><span class="line">        // 所以要利用一个中间的cnblogs域下的代理iframe</span><br><span class="line">        var ifrproxy = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        ifrproxy.style.display = <span class="string">'none'</span>;</span><br><span class="line">        ifrproxy.src = <span class="string">'http://a.com/test/cscript/cs3.html#somedata'</span>;    // 注意该文件在<span class="string">"a.com"</span>域下</span><br><span class="line">        document.body.appendChild(ifrproxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>a.com下的域名cs3.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(1);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/2050/p/3191744.html" target="_blank" rel="noopener">https://www.cnblogs.com/2050/p/3191744.html</a><br><a href="https://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="noopener">https://blog.csdn.net/joyhen/article/details/21631833</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/跨域请求/" data-id="cjqrhd64y000mjotenqlhjh9u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-post和get" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/post和get/" class="article-date">
  <time datetime="2019-01-09T01:37:41.275Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/post和get/">post和get区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.数据量：<br>post对请求参数的长度没有限制，而get如果请求参数过长，会被浏览器截断。<br>GET：不同的浏览器和服务器不同，一般限制在2~8K之间，更加常见的是1k以内<br>POST方法提交的数据比较大，大小靠服务器的设定值限制。<br>2.安全性：<br>get比post更不安全，get请求参数会直接暴露在URL上，所以不适合用来传递敏感信息。post放在request body中。<br>get请求只能进行url编码，而post支持多种编码方式。<br>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br>get请求在浏览器回退时是无害的，而post会再次提交请求。<br>3.缓存：<br>get请求产生的URL可以被浏览器主动缓存，而post请求不可以，除非手动设置。<br>4.效率：<br>get的意思是”得”，从服务器获取数据（也可以上传数据，参数就是），效率较高；<br>post的意思是“给”，但可以向服务器发送数据和下载数据，效率不如get；<br>get和post本质上就是TCP链接.get产生一个tcp数据包，post产生两个TCP数据包。<br>对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/post和get/" data-id="cjqrhd64g000bjotey6ublo8w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-generator和async函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/generator和async函数/" class="article-date">
  <time datetime="2019-01-08T02:23:48.429Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/08/generator和async函数/">Generator函数和async函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Generator函数可以理解成一个状态机，封装了多个内部状态。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">myGenerator</span></span>() &#123;</span><br><span class="line">	yield <span class="string">'hello'</span>;</span><br><span class="line">	yield <span class="string">'generator'</span>;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var mg = myGenerator();</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"hello"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"generator"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"ending"</span>, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>调用Generator函数后并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象（遍历器对象）。<br>因此必须调用遍历器的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或者上一次停下的地方开始执行，知道遇到下一个yield表达式或者return语句。<br>相当于。yield表达式是一个暂时执行的标记，next方法是一个恢复执行的标记。<br>value表示当前内部状态的值，done表示遍历是否结束。可以看到，当到函数执行结束时，done的属性就为true;</p>
<h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p>yield表达式没有返回值，next方法可以带一个参数，该参数会被当作上一个yield表达式的返回值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next() // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12) // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13) // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释：<br>b.next()返回yield (x + 1)的结果，因为x等于5，所以x+1为6；<br>b.next(12)，是将上一个yield的表达式的返回值当作12，因此约等于24，那么y/3就是8.<br>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。这个就需要用到yield* 表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'*foo()'</span>);</span><br><span class="line">    yield 3;</span><br><span class="line">    yield 4;</span><br><span class="line">    console.log(<span class="string">'*foo() finished!!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">bar</span></span>()&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield *foo();</span><br><span class="line">    yield 5;</span><br><span class="line">&#125;</span><br><span class="line">const it=bar();</span><br><span class="line">// 1 2 *foo() 3 4 *foo() finished!! 5</span><br></pre></td></tr></table></figure>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>1.async函数相当于Generator 函数的语法糖。前者比后者多了内置执行器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args)&#123; </span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>spawn 函数是一个自动执行器功能。<br>2.async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。一个函数如果加上async，那么干函数就会返回一个Promise.<br>3.await会暂停当前async函数的执行，等待后面的Promise的计算结果返回以后再继续执行当前的async函数。<br>但是await不是一直等待表达执行的执行结果，之后才会执行后面的代码。await后面的函数会先执行一遍，然后就会跳出整个 async 函数来执行后面js代码。等本轮事件循环执行完又跳回到 async 函数中等待await后面表达式的返回值，如果返回值为非 promise 则继续执行async后面的代码，否则将 promise 加入队列。<br>换句话说，当函数执行的时候，遇到 await 会立即返回一个 pending 状态的promise。<br>4.await等待的不是所有的异步操作，等待的时Promise.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">	await new Promise(resolve =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			console.log(2);</span><br><span class="line">			resolve();// 没有这一行就不会输出3</span><br><span class="line">		&#125;, 1000);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(3);</span><br><span class="line">&#125;)();</span><br><span class="line">// 1 2 3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> myAsync(num) &#123;</span><br><span class="line">	<span class="keyword">if</span> (num &gt; 0) &#123;</span><br><span class="line">		<span class="built_in">return</span> num;// resolve(num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		throw num;// reject(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myAsync(3).<span class="keyword">then</span>(value =&gt; &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myAsync(0).catch(<span class="keyword">function</span> (v) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">// 3 0</span><br></pre></td></tr></table></figure>
<h3 id="为什么产生"><a href="#为什么产生" class="headerlink" title="为什么产生"></a>为什么产生</h3><p>1.避免回调地狱 ==&gt; Promise ==&gt; async/await<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getData(a =&gt; &#123;</span><br><span class="line">	getMoreData(a, b =&gt; &#123;</span><br><span class="line">		getMoreMoreData(b, c =&gt; &#123;</span><br><span class="line">			console.log(c);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getData()</span><br><span class="line">.<span class="keyword">then</span>(a =&gt; getData(a))</span><br><span class="line">.<span class="keyword">then</span>(b =&gt; getMoreData(b))</span><br><span class="line">.<span class="keyword">then</span>(c =&gt; console.log(c))</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">	const a = await getData();</span><br><span class="line">	const b = await getMoreData(a);</span><br><span class="line">	const c = await getData(b);</span><br><span class="line">	console.log(c);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h2 id="async-await-promise-异步执行顺序"><a href="#async-await-promise-异步执行顺序" class="headerlink" title="async/await , promise 异步执行顺序"></a>async/await , promise 异步执行顺序</h2><p><a href="https://segmentfault.com/a/1190000016329715?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016329715?utm_source=tag-newest</a><br>实际上 await 是一个让出线程的标志（遇到 await 会立即返回一个 pending 状态的promise）。await后面的函数会先执行一遍，然后就会跳出整个 async 函数来执行后面js代码。等本轮事件循环执行完又跳回到 async 函数中等待await后面表达式的返回值，如果返回值为非 promise 则继续执行async后面的代码，否则将 promise 加入队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async2</span></span>() &#123;</span><br><span class="line">   console.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    console.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"script end"</span>);</span><br><span class="line">//执行结果：</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">settimeout</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">testFunc</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"testFunc..."</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"testFunc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">testAsync</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"testAsync..."</span>);</span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(<span class="string">"hello testAsync"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"test start..."</span>);</span><br><span class="line">    const v1 = await testFunc();</span><br><span class="line">    connsole.log(<span class="string">'hello world.'</span>);</span><br><span class="line">    console.log(v1);</span><br><span class="line">    const v2 = await testAsync();</span><br><span class="line">    console.log(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">var promise = new Promise(resolve =&gt; &#123; </span><br><span class="line">    console.log(<span class="string">"promise start.."</span>);</span><br><span class="line">    resolve(<span class="string">"promise"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">promise.then(val =&gt; console.log(val));</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"test end..."</span>);</span><br><span class="line">//执行结果：</span><br><span class="line"><span class="built_in">test</span> start...</span><br><span class="line">testFunc...</span><br><span class="line">promise start..</span><br><span class="line"><span class="built_in">test</span> end...</span><br><span class="line">hello world.</span><br><span class="line">testFunc</span><br><span class="line">testAsync...</span><br><span class="line">promise</span><br><span class="line">hello testAsync</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/generator和async函数/" data-id="cjqrhd6440002jotexbnta58e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/promise/" class="article-date">
  <time datetime="2019-01-07T01:48:20.573Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/promise/">Promise对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。</p>
<h2 id="promise含义"><a href="#promise含义" class="headerlink" title="promise含义"></a>promise含义</h2><p>1.Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>2.Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就固定，不会再变了，会一直保持这个结果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	console.log(<span class="string">'Promise'</span>);</span><br><span class="line">	<span class="function"><span class="title">if</span></span>() &#123;</span><br><span class="line">		resolve(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reject(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">	// success</span><br><span class="line">	&#125;,error =&gt; &#123;</span><br><span class="line">	// failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1.promise的构造函数接受一个函数作为参数，这个函数有两个参数分别是resolve和reject。而resolve和reject又各自是两个函数。<br>resolve函数，当Promise对象的状态从 pending 变为 resolved，在异步操作成功时调用，并将异步操作的结果作为参数value传递出去。<br>reject函数，当Promise对象的状态从pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误value,作为参数传递出去。<br>2.then方法的参数是两个回调函数：<br>第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数(可选)是Promise对象的状态变为rejected时调用。第二个参数是可选的。<br>then可以采用链式写法。<br>3.Promise 新建后就会立即执行。即回立马输出Promise。<br>4.Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<h2 id="resolve的参数是promise对象时："><a href="#resolve的参数是promise对象时：" class="headerlink" title="resolve的参数是promise对象时："></a>resolve的参数是promise对象时：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure>
<p>执行代码，p1是一个Promise,3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。<br>因此，后面的then语句变成针对P1。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<h2 id="Promise-prototype-finally-："><a href="#Promise-prototype-finally-：" class="headerlink" title="Promise.prototype.finally()："></a>Promise.prototype.finally()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;&#125;)</span><br><span class="line">.finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<h2 id="Promise-all-："><a href="#Promise-all-：" class="headerlink" title="Promise.all()："></a>Promise.all()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>p的状态由p1、p2、p3决定，分为两种情况。<br>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。<br>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
<h2 id="Promise-race-："><a href="#Promise-race-：" class="headerlink" title="Promise.race()："></a>Promise.race()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h2 id="Promise-resolve-："><a href="#Promise-resolve-：" class="headerlink" title="Promise.resolve()："></a>Promise.resolve()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象</p>
<p>Promise.resolve(‘foo’); &lt;==&gt; new Promise(resolve =&gt; resolve(‘foo’));</p>
<h2 id="构造函数和原型上的方法"><a href="#构造函数和原型上的方法" class="headerlink" title="构造函数和原型上的方法"></a>构造函数和原型上的方法</h2><p>1.<br>Promise.prototype.then()，Promise.prototype.catch()，Promise.prototype.finally();<br>Promise.all()，Promise.race()，Promise.resolve()，Promise.reject()，Promise.try();</p>
<p>2.在Promise构造函数上实现的all，race，reject，resolve，不能在对象的实例中访问，属于Promise构造函数自己，这样做保证了对象的命名空间整洁。所以这几个函数的调用方式是Promise.all()，Promise.race()，Promise.reject()，Promise.resolve()。</p>
<p>3.在构造函数原型上实现then，catch的方法是为了让Promise构造函数创建的实例共享then，catch方法。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.异步加载图片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loadImageAsync(url) &#123;</span><br><span class="line">	<span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		const image = new Image();</span><br><span class="line">		image.onload = () =&gt; resolve(image); </span><br><span class="line">		image.onerror = () =&gt; reject(new Error(<span class="string">'图片加载失败'</span>));</span><br><span class="line">		image.src = url;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .<span class="keyword">then</span>(2)</span><br><span class="line">  .<span class="keyword">then</span>(Promise.resolve(3))</span><br><span class="line">  .<span class="keyword">then</span>(console.log)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>3.实现一个简单的promise<br><a href="https://segmentfault.com/a/1190000009792439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009792439</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyPromise(fn) &#123;</span><br><span class="line">	this._status = <span class="string">'pending'</span>;</span><br><span class="line">	this._value = undefined;</span><br><span class="line">	this._onResolvedCallback = [];</span><br><span class="line">	this._onRejectCallback = [];</span><br><span class="line">	fn(resolve.bind(this), reject.bind(this));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> resolve(value) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'resolved'</span>;</span><br><span class="line">		this._value = value;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onResolvedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> reject(reason) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'reject'</span>;</span><br><span class="line">		this._value = reason;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onRejectedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="keyword">function</span>(onResolved, onRejected) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	var promise2;</span><br><span class="line">	onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="keyword">function</span>(v) &#123;&#125;;</span><br><span class="line">	onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="keyword">function</span> (r) &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(self._status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">		<span class="built_in">return</span> promise = new MyPromise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				 var x = onResolved(self._value);</span><br><span class="line">				 <span class="keyword">if</span>(x instanceof MyPromise) &#123;</span><br><span class="line">				 	x.then(resolve, reject);</span><br><span class="line">				 &#125;</span><br><span class="line">				 resolve(x);</span><br><span class="line">			&#125; catch(e) &#123;</span><br><span class="line">				reject(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (self._status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">	    <span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">	      try &#123;</span><br><span class="line">	        var x = onRejected(self._value)</span><br><span class="line">	        <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">	          x.then(resolve,reject)</span><br><span class="line">	        &#125;</span><br><span class="line">	      &#125; catch(e) &#123;</span><br><span class="line">	        reject(e)</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(self._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">  	<span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  		self._onResolvedCallback.push(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          var x = onResolved(self._value)</span><br><span class="line">          <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self._onRejectCallback.push(<span class="keyword">function</span>(reason) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x =onRejected(self._value)</span><br><span class="line">          <span class="keyword">if</span>(x instanceof Promise) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//<span class="built_in">test</span> code</span><br><span class="line">  var myFirstPromise = new MyPromise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          resolve(<span class="string">"成功!"</span>); //代码正常执行！</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  myFirstPromise.then(<span class="keyword">function</span> (successMessage) &#123;</span><br><span class="line">     console.log(<span class="string">"Yay! "</span> + successMessage);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/promise/" data-id="cjqrhd6490007jote4v97yfnk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-macrotask microtask" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/macrotask microtask/" class="article-date">
  <time datetime="2019-01-05T02:02:14.058Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/macrotask microtask/">macrotask microtask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>macrotask翻译过来，是宏任务的意思，我们常说的任务队列就指的是macrotask；<br>microtask翻译过来，是微任务的意思</p>
<p>js是单线程的，意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务。因此，将所有的任务分成两种，一种是同步任务synchronous，另一种是异步任务asynchronous。<br>同步任务指的是在主线程上排队执行的任务，也就是平常所说的执行队列，这个里面的任务必须要个按照次序依次执行，只有前一个执行完了，才可以执行下一个。<br>异步任务指的是不进入主线程，而进入“任务队列”task queue的任务，只有当“任务队列”通知主线程某个异步任务可以执行了，该任务才可以进入主线程执行。异步任务执行的时候，执行的就是定义的回调函数。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br>异步执行的运行机制如下：<br>1.所有同步任务都是在主线程上执行，形成一个执行栈execution context stack。<br>2.主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。<br>3.一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4.主线程不断重复上面的第三步。</p>
<h2 id="macrotask-microtask"><a href="#macrotask-microtask" class="headerlink" title="macrotask microtask"></a>macrotask microtask</h2><p>macrotask和microtask都属于上述的异步任务中的一种，其中：<br>macrotasks: script,setTimeout, setInterval, setImmediate, I/O, UI rendering，requestAnimationFrame；<br>microtasks: process.nextTick, Promise, MutationObserver，Object.observe；<br>microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务，例如响应时间，以避免付出额外的一个task代价。</p>
<p>我们看到的很多代码是这样的：<br>因为宏任务包括了script，所以浏览器会执行一个宏任务，接下来有异步代码的话就先执行微任务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>macrotask就是常说的任务队列task queue。<br>js执行顺序如下：<br>开始 -&gt; 取任务队列的第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取任务队列的第一个task执行 -&gt; 取microtask全部任务依次执行…循环往复<br>直到两个队列全部任务执行完毕</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">let</span> p1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'Promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then((res)=&gt;&#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line">//Promise1 1 Promise2 setTimeout</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>整个script代码，放在了macrotask queue中,执行到setTimeout时会新建一个macrotask queue，promise.then放到了另一个microtask queue中。<br>script的执行引擎会取1个macrotask queue中的task，执行之。<br>然后把所有microtask queue顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(1);&#125;, 0);</span><br><span class="line">console.log(2);</span><br><span class="line">//2 1</span><br></pre></td></tr></table></figure>
<p>因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/macrotask microtask/" data-id="cjqrhd6450003jotehqznmysn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/19/this学习/" class="article-date">
  <time datetime="2018-12-19T07:30:07.000Z" itemprop="datePublished">2018-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/19/this学习/">this学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么会出现this问题？"><a href="#为什么会出现this问题？" class="headerlink" title="为什么会出现this问题？"></a>为什么会出现this问题？</h2><p>参考链接：<a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/06/javascript-this.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	bar: 1,</span><br><span class="line">	foo: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		console.log(this.bar);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var foo = obj.foo;</span><br><span class="line">var bar = 2;</span><br><span class="line">obj.foo();//1</span><br><span class="line">foo();//2</span><br></pre></td></tr></table></figure></p>
<p>出现这种情况的原因是，this指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以this指向obj;但是对于foo()来说是运行在全局环境中，所以this指向全局环境，即window.</p>
<h3 id="js内存的数据结构"><a href="#js内存的数据结构" class="headerlink" title="js内存的数据结构"></a>js内存的数据结构</h3><p>1.当属性的值是一个数值的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于这段代码，js引擎会首先在内存里面生成一个对象{ foo:  5 }，然后把该对象的地址赋值给obj。<br>原始的对象是以字典的形式保存的，每一个属性名都对应一个对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 5</span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/19/this学习/属性值是数值.png" alt="属性值是数值"></p>
<p>2.当属性的值是一个函数的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="function"><span class="title">function</span></span> () &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个时候在内存中会存在一个函数，并且将这个函数的地址赋值给foo属性的value属性。<br><img src="/2018/12/19/this学习/属性值是函数.png" alt="属性值是函数"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正是由于函数是一个单独的值，所以它可以在不同的环境（上下文）中执行。那么就需要一种机制，可以在函数内部获得当前的运行环境（上下文），这个机制就是this.它的存在就是表示函数的当前运行环境。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  foo: f,</span><br><span class="line">  x: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f() // 1</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f() // 2</span><br></pre></td></tr></table></figure>
<p>1.图形解释f()结果:<br><img src="/2018/12/19/this学习/f结果.png" alt="f()结果"><br>2.图形解释obj.f()结果:<br><img src="/2018/12/19/this学习/obj.f结果.png" alt="obj.f()结果"></p>
<p>那么此时就明白了：对于obj.foo()来说，是通过obj找到foo，所以就是在obj环境中执行的；<br>但是对于var foo = obj.foo;，那么变量foo就直接指向函数本身，所以此时foo()就变成是在全局环境中执行的。</p>
<h2 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h2><h3 id="全局环境："><a href="#全局环境：" class="headerlink" title="全局环境："></a>全局环境：</h3><p>在全局环境下，无论是否是严格模式，this始终指向全局对象window</p>
<h3 id="函数上下文调用："><a href="#函数上下文调用：" class="headerlink" title="函数上下文调用："></a>函数上下文调用：</h3><p>1.函数直接调用时：<br>非严格模式下，this指向全局对象window；严格模式下，this为undefined.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">console.log(f1() === window) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">  <span class="string">"use strict"</span>; // 这里是严格模式</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">console.log(f2() === undefined) // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>2.对象中的this：<br>依照下面的法则去替换即可：（谁调用它，this就指向谁）<br>foo() —&gt; foo.call(window)<br>obj.foo() –&gt; obj.foo.call(obj)</p>
<p>3.构造函数的this<br>构造函数中的this与被创建的新对象绑定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">C</span></span>()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  <span class="built_in">return</span> &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var b = new C();</span><br><span class="line">console.log(b.a); //38</span><br></pre></td></tr></table></figure></p>
<p>4.call &amp; apply和bind方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(c, d)&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tt</span></span>() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">tt.call(5);  // Number &#123;[[PrimitiveValue]]: 5&#125; </span><br><span class="line">tt.call(<span class="string">'asd'</span>); // String &#123;0: <span class="string">"a"</span>, 1: <span class="string">"s"</span>, 2: <span class="string">"d"</span>, length: 3, [[PrimitiveValue]]: <span class="string">"asd"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>bind方法，会将函数永远绑定在其第一个参数对象上，无论在什么情况下被调用，它的this指向都不变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a;</span><br><span class="line">&#125;</span><br><span class="line">var g = f.bind(&#123;a:<span class="string">"azerty"</span>&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure></p>
<p>5.DOM事件处理函数中的this<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"myBtn"</span> onclick=<span class="string">"test()"</span>&gt;click&lt;/button&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> listenerTest(e)&#123;</span><br><span class="line">      console.log(this);//输出&lt;button id=<span class="string">"myBtn"</span> onclick=<span class="string">"test()"</span>&gt;click&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(<span class="string">"myBtn"</span>).addEventListener(<span class="string">'click'</span>, listenerTest, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">      //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames:Window, listenerTest:ƒ listenerTest(e)…&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(document.getElementById(<span class="string">"myBtn"</span>).onclick);//ƒ onclick(event) &#123;<span class="built_in">test</span>()&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>我对上述代码的控制台输出的理解：<br>因为listenerTest方法是绑定到button对象上，所以里面的this指向button;<br>而test方法是赋给了onclick属性，点击时，是window调用的test方法，所以打印出来的是window，并且可以看到在window里有listenerTest方法。点击时，是执行了window.onclick()方法，只不过onclick()里调用了test()函数。</p>
<p>5.1 当函数被当作监听事件处理函数（addEventListen）时，其中的this指向触发该事件的元素。<br>5.2 当代码被内联函数调用时，this指向监听器所在的DOM元素；当代码被包括在函数内部执行时，this指向全局对象window或者undefined.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"console.log(this);"</span>&gt;click&lt;/button&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"(function() &#123;console.log(this)&#125;)();"</span>&gt;show inner&lt;/button&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"(function() &#123;'use strict';console.log(this)&#125;)();"</span>&gt;use strict&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>依次点击这三个按钮后，控制台输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"console.log(this);"</span>&gt;click&lt;/button&gt;</span><br><span class="line">Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p>
<p>6.setTimeout &amp; setInterval<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).<span class="built_in">bind</span>(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person &#123;age: 0&#125;</span><br></pre></td></tr></table></figure>
<p>7.箭头函数中的this<br>7.1 箭头函数在方法内部<br>箭头函数会自己捕获所在的上下文的this值，即定义的位置。call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对this毫无影响。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person &#123;age: 0&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : <span class="keyword">function</span>(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    <span class="built_in">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="keyword">function</span> inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(adder.add(1));         //2</span><br><span class="line">console.log(adder.addThruCall(1)); //2</span><br></pre></td></tr></table></figure>
<p>7.2 作为方法的箭头函数<br>作为方法的箭头函数的this指向全局对象window,而普通函数则指向调用它的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  arrow: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.arrow();  //undefined Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br><span class="line">obj.c(); //10 &#123;i: 10, arrow: ƒ, c: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>学习参考链接：<br><a href="http://www.imooc.com/article/1758" target="_blank" rel="noopener">http://www.imooc.com/article/1758</a><br><a href="http://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongcanliang/p/7054176.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/19/this学习/" data-id="cjqrhd64b0009joterihl1x22" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包和立即执行函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/18/闭包和立即执行函数/" class="article-date">
  <time datetime="2018-12-18T01:54:17.096Z" itemprop="datePublished">2018-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/18/闭包和立即执行函数/">闭包和立即执行函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包closure"><a href="#闭包closure" class="headerlink" title="闭包closure"></a>闭包closure</h2><p>闭包的定义就是：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被成为闭包。</p>
<h3 id="为什么会有闭包的出现？"><a href="#为什么会有闭包的出现？" class="headerlink" title="为什么会有闭包的出现？"></a>为什么会有闭包的出现？</h3><p>假设现在有一个需求：想定义一个变量，使得计数的时候可以加1。<br>最直接想到的代码为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i=0;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">console.log(i);//1</span><br></pre></td></tr></table></figure></p>
<p>但是全局变量i有风险，因为可能不小心在哪里就改掉它了，但是用局部变量的话，它就只能在函数内部有效，调用完函数后它就没了，而且全局没法使用。所以现在的需求就是想让这个计数器可以在全局使用，但又不能被随便修改。此时闭包就要出场了~</p>
<h3 id="什么是闭包函数？"><a href="#什么是闭包函数？" class="headerlink" title="什么是闭包函数？"></a>什么是闭包函数？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = add();</span><br><span class="line">console.log(a1());//1</span><br><span class="line">console.log(a1());//2</span><br><span class="line"></span><br><span class="line">var a2 = add();</span><br><span class="line">console.log(a2());//1</span><br></pre></td></tr></table></figure>
<p>每次调用add()函数后会生成一个计数器，而且不同的计数器之间是不干扰的。<br>我们不能自己操控变量i，但是可以通过特定的方法“add中返回的匿名函数”去操作它。</p>
<p>总结一下，闭包函数最大的特点就是：创建内部变量，使得这些变量不能被外部随意修改，然后只能通过特定的方法才可以访问操作它。</p>
<p>对于有多个特定方法可以操作变量时，可以考虑下述写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">count</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">minus</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> --i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> &#123;</span><br><span class="line">		outerAdd: add,</span><br><span class="line">		outerMinus: minus</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var count1 = count();</span><br><span class="line">console.log(count1.outerAdd());//1</span><br><span class="line">console.log(count1.outerMinus());//0</span><br></pre></td></tr></table></figure></p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><h3 id="为什么会有立即函数的出现？"><a href="#为什么会有立即函数的出现？" class="headerlink" title="为什么会有立即函数的出现？"></a>为什么会有立即函数的出现？</h3><p>在闭包的基础上，现在又有这样的需求：就是我们希望对象只有一份，不像上部分中既有a1又有a2，类似后端中的单例模式。那么我们想到的解决思路就是保证这个方法只能被调用一次。<br>首先因为不能多次调用，那么就需要是匿名的；然后因为只能被调用一次，那么必须在声明的时候立马执行。这个时候就出现了立即执行函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var count1 = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">minus</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> --i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> &#123;</span><br><span class="line">		outerAdd: add,</span><br><span class="line">		outerMinus: minus</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(count1.outerAdd());//1</span><br><span class="line">console.log(count1.outerAdd());//2</span><br><span class="line">console.log(count1.outerMinus());//1</span><br></pre></td></tr></table></figure>
<p>count1就是这个匿名函数返回的一个对象，该对象有两个属性：outerAdd和outerMinus，每个属性分别对应一个函数的定义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/18/闭包和立即执行函数/" data-id="cjqrhd64w000ljoteqq81hilo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-异步，同步，回调和class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/异步，同步，回调和class/" class="article-date">
  <time datetime="2018-12-05T03:18:44.947Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/异步，同步，回调和class/">异步，同步，回调和js的class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉阮一峰对异步，同步和回调的解释，很通俗，所以在这里记一下.<br>链接：<a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator-async</a></p>
<h2 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h2><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。<br>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<h2 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h2><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h2 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h2><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。</p>
<h2 id="class："><a href="#class：" class="headerlink" title="class："></a>class：</h2><p>ES6 的类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注：<br>类里面会用到super关键字，super这个关键字，既可以当作函数使用，也可以当作对象使用。第一种情况，super作为函数调用时，代表父类的构造函数。第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/05/异步，同步，回调和class/" data-id="cjqrhd64l000gjotem43074gh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/11/渲染机制/">渲染机制</a>
          </li>
        
          <li>
            <a href="/2019/01/10/存储/">存储</a>
          </li>
        
          <li>
            <a href="/2019/01/09/跨域请求/">js跨域请求</a>
          </li>
        
          <li>
            <a href="/2019/01/09/post和get/">post和get区别</a>
          </li>
        
          <li>
            <a href="/2019/01/08/generator和async函数/">Generator函数和async函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>