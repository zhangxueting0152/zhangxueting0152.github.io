<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-决策树与随机森林" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/决策树与随机森林/" class="article-date">
  <time datetime="2019-07-22T12:35:35.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/决策树与随机森林/">决策树与随机森林</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="决策树与随机森林"><a href="#决策树与随机森林" class="headerlink" title="决策树与随机森林"></a>决策树与随机森林</h2><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树是一种树形结构，其中每个内部节点表示一个属性特征上的测试，每个分支代表一个测试输出。决策树衡量分叉的标准有信息熵或者gini系数，这里主要说信息熵。其关键点在于使用信息增益来寻找最优特征。信息增益I可以理解为在已知一个特征条件下，问题的不确定性会降低多少的量度。公式如下：<br><img src="/2019/07/22/决策树与随机森林/0.png" alt="决策树公式"> </p>
<p>优点：</p>
<pre><code>可解释性高，决策树可以看成是一个if-else的可视化的结果；

能处理非线性数据；

不需要做数据的归一化，因为不同属性的数据之间不需要做类似乘法这种运算；

可以用于特征工程，特征选择。
</code></pre><p>缺点：</p>
<pre><code>容易产生过拟合，为了避免该问题，可以在定义模型的时候使用下述三种方法：
    max_depth=3, # 定义树的深度, 可以用来防止过拟合
    min_samples_split=10, # 定义至少多少个样本的情况下才继续分叉
    min_weight_fraction_leaf=0.02 # 定义叶子节点最少需要包含多少个样本(使用百分比表达), 防止过拟合
微小的数据改变回改变整个树的形状，为了避免这个缺点，因此有了随机森林的出现；
对类别不平衡的数据不友好。
</code></pre><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林属于集成学习的一种，它是同时训练多个决策树，综合考虑多个结果进行预测，当出现多个结果时，如果该问题是回归问题，则可以考虑取均值；如果该问题是分类问题，则可以考虑取众数，即类似投票的方式。当然处理方式不止均值和众数两种。如下图所示，图片来源（<a href="https://blog.csdn.net/edogawachia/article/details/79357844）" target="_blank" rel="noopener">https://blog.csdn.net/edogawachia/article/details/79357844）</a></p>
<p><img src="/2019/07/22/决策树与随机森林/1.jpg" alt="随机森林"> </p>
<p>随机性体现在两点：</p>
<pre><code>从原来的训练数据集中带放回(例如bootstrap)的随机取一个子集作为森林中某一个决策树的训练数据集；每一次选择分叉的特征时，限定为在随机选择的特征子集中寻找一个特征。
</code></pre><p>优点：</p>
<pre><code>解决了决策树容易过拟合的问题；预测值不会因为训练数据的微小变化而剧烈变化。
</code></pre><p>注：随机森林和adaboost都属于继承学习的一种，但是随机森林中是并行的，树与树之间是隔离的；但是adaboost中可能前一棵树的输出会影响后一棵树的建立。</p>
<h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><p>1.决策树做预测<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的决策树, 限定树的最大深度, 减少过拟合</span></span><br><span class="line">dtree = DecisionTreeClassifier(</span><br><span class="line">    criterion=<span class="string">'entropy'</span>,</span><br><span class="line">    max_depth=3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">dtree = dtree.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">y_pred = dtree.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型的性能</span></span><br><span class="line">dt_roc_auc = metrics.accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"决策树的Accuracy:"</span>,dt_roc_auc)</span><br><span class="line"><span class="comment"># 决策树的Accuracy: 0.7705627705627706</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/22/决策树与随机森林/2.jpg" alt="决策树"> </p>
<p>2.随机森林做预测<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机森林, 通过调整参数来获取更好的结果</span></span><br><span class="line">rf = RandomForestClassifier(</span><br><span class="line">    criterion=<span class="string">'entropy'</span>,</span><br><span class="line">    n_estimators=1000, </span><br><span class="line">    max_depth=None, <span class="comment"># 定义树的深度, 可以用来防止过拟合</span></span><br><span class="line">    min_samples_split=10, <span class="comment"># 定义至少多少个样本的情况下才继续分叉</span></span><br><span class="line">    <span class="comment">#min_weight_fraction_leaf=0.02 # 定义叶子节点最少需要包含多少个样本(使用百分比表达), 防止过拟合</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做预测</span></span><br><span class="line">y_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型的准确率</span></span><br><span class="line">rf_roc_auc = metrics.accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"随机森林的Accuracy:"</span>,rf_roc_auc)</span><br></pre></td></tr></table></figure></p>
<p>随机森林的Accuracy: 0.7965367965367965</p>
<p>3.roc图比较决策树和随机森林的预测结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROC 图</span></span><br><span class="line">from sklearn.metrics import roc_curve</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">rf_fpr, rf_tpr, rf_thresholds = roc_curve(y_test, rf.predict_proba(X_test)[:,1])</span><br><span class="line">dt_fpr, dt_tpr, dt_thresholds = roc_curve(y_test, dtree.predict_proba(X_test)[:,1])</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机森林 ROC</span></span><br><span class="line">plt.plot(rf_fpr, rf_tpr, label=<span class="string">'Random Forest (area = %0.2f)'</span> % rf_roc_auc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策树 ROC</span></span><br><span class="line">plt.plot(dt_fpr, dt_tpr, label=<span class="string">'Decision Tree (area = %0.2f)'</span> % dt_roc_auc)</span><br><span class="line"></span><br><span class="line">plt.xlim([0.0, 1.0])</span><br><span class="line">plt.ylim([0.0, 1.05])</span><br><span class="line">plt.xlabel(<span class="string">'False Positive Rate'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'True Positive Rate'</span>)</span><br><span class="line">plt.title(<span class="string">'ROC Graph'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"lower right"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/22/决策树与随机森林/3.jpg" alt="决策树"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/决策树与随机森林/" data-id="cjyedyp0t000g2ktebbbcjirq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-回归分析和朴素贝叶斯学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/回归分析和朴素贝叶斯学习笔记/" class="article-date">
  <time datetime="2019-07-05T08:12:09.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/回归分析和朴素贝叶斯学习笔记/">回归分析和朴素贝叶斯学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>语言：python<br>使用的是jupyter</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>回归分为线性回归和逻辑回归：</p>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>其中线性回归预测的是连续值；</p>
<p>模型： <img src="/2019/07/05/回归分析和朴素贝叶斯学习笔记/1.jpg" alt="线性回归公式"></p>
<p>Y是观测值的列向量， [公式] 是参数值的列向量</p>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归预测的是离散值，分类问题。</p>
<p><img src="/2019/07/05/回归分析和朴素贝叶斯学习笔记/2.jpg" alt="逻辑回归公式"></p>
<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>为什么做特征工程？因为机器学习有”garbage in, garbage out”的特点，因此对数据的处理就十分重要。</p>
<p>在特征工程里，遇到分类问题，经常会遇到类不平衡数据，那么可以考虑使用smote方法，即过采样少数类。之所以不直接删掉多数类的数据来使得数据平衡，是因为考虑到如果删掉太多数据的话，会丢失数据里的很多信息。</p>
<h3 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h3><p>SMOTE算法的基本思想就是从少数类别中创建假想样本。例如从少数类别中选取两个相似样本A和B，调整某个属性的值，比如取A和B属性的平均数/众数等，来生成该假想数据的特征值。由于该假想样本的特征值是由真实数据产生的，所以认为该假想样本与真实样本很接近。</p>
<h3 id="代码练习部分"><a href="#代码练习部分" class="headerlink" title="代码练习部分"></a>代码练习部分</h3><p>数据处理部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">count_no_sur = len(data[data[<span class="string">'survived'</span>]==0])</span><br><span class="line">count_sur = len(data[data[<span class="string">'survived'</span>]==1])</span><br><span class="line">pct_of_no_sur = count_no_sur/(count_no_sur+count_sur)</span><br><span class="line">pct_of_sur = count_sur/(count_no_sur+count_sur)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'未生还的百分比:  %.2f%%'</span> % (pct_of_no_sur*100))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'生还的百分比:  %.2f%%'</span> % (pct_of_sur*100))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为大部分是生还的，因此给缺失的生还数据补0</span></span><br><span class="line">data[<span class="string">"survived"</span>].fillna(df[<span class="string">"survived"</span>].value_counts().idxmax(), inplace=True)</span><br><span class="line">data.isnull().sum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看fare特征的偏度 因为不为0，所以使用中间值代替缺失值</span></span><br><span class="line">df[<span class="string">"fare"</span>].skew()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'The median of "fare" is %.2f'</span> %(df[<span class="string">"fare"</span>].median(skipna=True)))</span><br><span class="line">data[<span class="string">"fare"</span>].fillna(df[<span class="string">"fare"</span>].median(skipna=True), inplace=True)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑一共有1300多条数据，剩下的特征值里有缺失数据的数量很少，因此可以考虑不需要这些数据</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">axis：0-行操作（默认），1-列操作 </span></span><br><span class="line"><span class="string">how：any-只要有空值就删除（默认），all-全部为空值才删除 </span></span><br><span class="line"><span class="string">inplace：False-返回新的数据集（默认），True-在愿数据集上操作</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">data.dropna(axis=0, how=<span class="string">'any'</span>, inplace=True)</span><br><span class="line"><span class="comment"># 确认数据是否还包含缺失数据</span></span><br><span class="line">data.isnull().sum()</span><br></pre></td></tr></table></figure></p>
<p>模型训练部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line"></span><br><span class="line">final.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用如下特征做预测</span></span><br><span class="line">cols = [<span class="string">"age"</span>,<span class="string">"fare"</span>,<span class="string">"TravelAlone"</span>,<span class="string">"pclass"</span>,<span class="string">"embarked_C"</span>,<span class="string">"embarked_S"</span>,<span class="string">"sex_male"</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 X (特征) 和 y (类别标签)</span></span><br><span class="line">X = final[cols]</span><br><span class="line">y = final[<span class="string">'survived'</span>]</span><br><span class="line"><span class="comment"># 将 X 和 y 分为两个部分</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2)</span><br><span class="line"></span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line"><span class="comment"># 1.训练模型,  </span></span><br><span class="line">logreg.fit(X_train, y_train.values.reshape(-1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.根据模型, 以 X_test 为输入, 生成变量 y_pred</span></span><br><span class="line">y_pred = logreg.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Train/Test split results:'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准确率为 %2.3f"</span> % accuracy_score(y_test, y_pred))</span><br></pre></td></tr></table></figure></p>
<p>ROC曲线分析<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line"></span><br><span class="line">final.head()</span><br><span class="line"></span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line">from sklearn.metrics import roc_auc_score</span><br><span class="line">from sklearn.metrics import roc_curve</span><br><span class="line">logit_roc_auc = roc_auc_score(y_test, logreg.predict(X_test))</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_test, logreg.predict_proba(X_test)[:,1])</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(fpr, tpr, label=<span class="string">'Logistic Regression (area = %0.2f)'</span> % logit_roc_auc)</span><br><span class="line">plt.plot([0, 1], [0, 1],<span class="string">'r--'</span>)</span><br><span class="line">plt.xlim([0.0, 1.0])</span><br><span class="line">plt.ylim([0.0, 1.05])</span><br><span class="line">plt.xlabel(<span class="string">'False Positive Rate'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'True Positive Rate'</span>)</span><br><span class="line">plt.title(<span class="string">'Receiver operating characteristic'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"lower right"</span>)</span><br><span class="line">plt.savefig(<span class="string">'Log_ROC'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/05/回归分析和朴素贝叶斯学习笔记/3.jpg" alt="ROC曲线"></p>
<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>该方法是比较适合简单的文本分析的一种算法</p>
<p><img src="/2019/07/05/回归分析和朴素贝叶斯学习笔记/4.jpg" alt="公式"></p>
<p>在做文本分析的时候，会使用很多种方法去将文本信息转换成文本向量，常用的一种方法叫做Tf-idf.</p>
<p>之所以叫朴素贝叶斯，是因为假设了条件独立。</p>
<p>最大似然估计：是根据观测到的结果来预测其中的未知数。</p>
<p>生成模型与判别模型：生成模型是用于生成数据的，比如代码、图片；判别模型只需要记住需判别的物体之间的区别；朴素贝叶斯就是生成模型，逻辑回归就是判别模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/05/回归分析和朴素贝叶斯学习笔记/" data-id="cjyedyp0v000i2kterhcrs4zh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线性回归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/线性回归/" class="article-date">
  <time datetime="2019-06-24T11:11:11.000Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/线性回归/">线性回归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>语言：python<br>使用的是jupyter<br>题目:</p>
<p>•气温会随着海拔高度的升高而降低, 我们可以通过测量不同海拔高度的气温来预测海拔高度和气温的关系.</p>
<p>•我们假设海拔高度和气温的关系可以使用如下公式表达:</p>
<p>•y(气温) = a * x(海拔高度) + b</p>
<p>•理论上来讲, 确定以上公式 a 和 b的值只需在两个不同高度测试, 就可以算出来 a 和 b 的值了. 但是由于所有的设备都是有误差的, 而使用更多的高度测试的值可以使得预测的值更加准确.</p>
<p>•我们提供了在9个不同高度测量的气温值, 请你根据今天学习的线性回归方法预测 a 和 b 的值. 根据这个公式, 我们预测一下在8000米的海拔, 气温会是多少?</p>
<p>数据如下图所示：<br><img src="/2019/06/24/线性回归/1.jpg" alt="训练数据"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.linear_model import LinearRegressionp</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'./height.vs.temperature.csv'</span>)</span><br><span class="line">data.head()</span><br><span class="line">data.columns</span><br></pre></td></tr></table></figure>
<h2 id="对数据继续可视化分析"><a href="#对数据继续可视化分析" class="headerlink" title="对数据继续可视化分析"></a>对数据继续可视化分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(16, 8))</span><br><span class="line">plt.scatter(data[<span class="string">'height'</span>], data[<span class="string">'temperature'</span>], c=<span class="string">'black'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'height'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'temperature'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/24/线性回归/2.jpg" alt="可视化分析数据"></p>
<h2 id="训练线性回归模型"><a href="#训练线性回归模型" class="headerlink" title="训练线性回归模型"></a>训练线性回归模型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X = data[<span class="string">'height'</span>].values.reshape(-1, 1)</span><br><span class="line">y = data[<span class="string">'temperature'</span>].values.reshape(-1, 1)</span><br><span class="line"></span><br><span class="line">reg = LinearRegression()</span><br><span class="line">reg.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a = &#123;:.5&#125;'</span>.format(reg.coef_[0][0]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'b = &#123;:.5&#125;'</span>.format(reg.intercept_[0]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'线性模型为： Y = &#123;:.5&#125;X + &#123;:.5&#125;'</span>.format(reg.coef_[0][0], reg.intercept_[0]))</span><br></pre></td></tr></table></figure>
<p>a = -0.0065695<br>b = 12.719<br>线性模型为： Y = -0.0065695X + 12.719</p>
<h2 id="可视化模型"><a href="#可视化模型" class="headerlink" title="可视化模型"></a>可视化模型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">predictions = reg.predict(X)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(16, 8))</span><br><span class="line">plt.scatter(data[<span class="string">'height'</span>], data[<span class="string">'temperature'</span>], c=<span class="string">'black'</span>)</span><br><span class="line">plt.plot(data[<span class="string">'height'</span>], predictions, c=<span class="string">'blue'</span>, lineWidth=2)</span><br><span class="line">plt.xlabel(<span class="string">'height'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'temperature'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/24/线性回归/3.jpg" alt="可视化模型"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predictions = reg.predict([[8000]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'在8000米的海拔, 气温会是&#123;:.5&#125;'</span>.format(predictions[0][0]))</span><br></pre></td></tr></table></figure>
<p>在8000米的海拔, 气温会是-39.838</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/24/线性回归/" data-id="cjyedyp12000r2ktecc32tmmq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS隐藏元素" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/20/CSS隐藏元素/" class="article-date">
  <time datetime="2019-06-20T02:37:12.675Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/20/CSS隐藏元素/">CSS隐藏元素</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-opacity"><a href="#1-opacity" class="headerlink" title="1)    opacity"></a>1)    opacity</h2><p>视觉上它是消失了,但是他依然占据着那个位置。它也将响应用户交互。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.myDiv&#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.myDiv:hover&#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-display：none"><a href="#2-display：none" class="headerlink" title="2)    display：none"></a>2)    display：none</h2><p>该元素会从视觉中消失,并且连盒模型也不生成.也不会在页面占据任何位置。不响应交互。</p>
<h2 id="3-visibility-hidden"><a href="#3-visibility-hidden" class="headerlink" title="3)    visibility:hidden"></a>3)    visibility:hidden</h2><p>元素将会隐藏，也会占据着自己的位置，并对网页的布局起作用。不会响应任何用户交互。</p>
<h2 id="4-position：absolute"><a href="#4-position：absolute" class="headerlink" title="4)    position：absolute"></a>4)    position：absolute</h2><p>视觉上它是消失了,但是他依然占据着那个位置。它也将响应用户交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   top: -9999px;</span><br><span class="line">   left: -9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/20/CSS隐藏元素/" data-id="cjyedyp0b00012kte584yvjpv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BFC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/BFC/" class="article-date">
  <time datetime="2019-03-26T12:13:18.000Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/BFC/">BFC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><h3 id="Formatting-context"><a href="#Formatting-context" class="headerlink" title="Formatting context"></a>Formatting context</h3><p>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>“块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><p>内部的Box会在垂直方向，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。<br>生成BFC元素的子元素中，每一个子元素的外边距会与包含块的左边界相接触，即使存在浮动也是如此。除非这个子元素也创建了一个新的BFC。<br>BFC的区域不会与float box重叠。<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算BFC的高度时，浮动元素也参与计算。</p>
<h3 id="BFC如何产生-满足任何一个条件即可"><a href="#BFC如何产生-满足任何一个条件即可" class="headerlink" title="BFC如何产生(满足任何一个条件即可)"></a>BFC如何产生(满足任何一个条件即可)</h3><p>根元素<br>float属性不为none<br>position为absolute或fixed，即为绝对定位元素<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>overflow不为visible</p>
<h2 id="BFC作用"><a href="#BFC作用" class="headerlink" title="BFC作用"></a>BFC作用</h2><h3 id="1-清除内部浮动（当浮动元素无法撑起父元素时）"><a href="#1-清除内部浮动（当浮动元素无法撑起父元素时）" class="headerlink" title="1.清除内部浮动（当浮动元素无法撑起父元素时）"></a>1.清除内部浮动（当浮动元素无法撑起父元素时）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line"><span class="comment">#father &#123;</span></span><br><span class="line">	width: 300px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	border: 2px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 300px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">	<span class="built_in">float</span>: left;</span><br><span class="line">	border: 2px solid red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=<span class="string">"father"</span>&gt;</span><br><span class="line">		&lt;div class=<span class="string">"child"</span>&gt;child1&lt;/div&gt;</span><br><span class="line">		&lt;div class=<span class="string">"child"</span>&gt;child2&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/1_1.png" alt="1_1"><br>修改原理：计算BFC的高度时，浮动元素也参与计算。所以为了达到清除内部浮动的目的，可以让father div生成一个BFC。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#father &#123;</span></span><br><span class="line">	width: 300px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	border: 2px solid blue;</span><br><span class="line">	overflow: hidden; // father变成BFC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/1_2.png" alt="1_2"></p>
<h3 id="2-解决垂直margin重叠"><a href="#2-解决垂直margin重叠" class="headerlink" title="2.解决垂直margin重叠"></a>2.解决垂直margin重叠</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">p &#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	margin: 50px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;box2&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/2_1.png" alt="2_1"><br>可以看到，box1和box2的距离是100px，不是我们预期的200px。发生了maigin重叠。<br>修改原理：box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box会发生margin重叠。那么我们可以在box2外面包裹一层容器，并出发该容器生成一个BFC。那么两个div就不属于同于一个BFC了，也就不会margin重叠了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">p &#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	margin: 50px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#bfc &#123;</span></span><br><span class="line">	overflow: hidden; // **</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">	&lt;div id=<span class="string">"bfc"</span>&gt; // **</span><br><span class="line">		&lt;p&gt;box2&lt;/p&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/2_2.png" alt="2_2"><br>注意，直接给box2加bfc不起作用，必须给box2外面包裹一层。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"bfc"</span>&gt;box2&lt;/p&gt; // 错误</span><br></pre></td></tr></table></figure></p>
<h3 id="3-自适应两栏布局（解决不被浮动元素覆盖问题）"><a href="#3-自适应两栏布局（解决不被浮动元素覆盖问题）" class="headerlink" title="3.自适应两栏布局（解决不被浮动元素覆盖问题）"></a>3.自适应两栏布局（解决不被浮动元素覆盖问题）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">.aside &#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 100px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	<span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">	height:  120px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=<span class="string">"aside"</span>&gt;aside&lt;/div&gt;</span><br><span class="line">	&lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/3_1.png" alt="3_1"><br>修改原理：每个元素的margin box的左边， 与包含块border box的左边相接触。因此，虽然存在浮动的元素aside，但main的左边依然会与包含块的左边相接触。但是BFC的区域不会与float box重叠。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">	height:  120px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">	overflow: hidden; // **</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/3_2.png" alt="3_2"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/BFC/" data-id="cjyedyp0600002ktel537h8p6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-位运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/17/位运算符/" class="article-date">
  <time datetime="2019-03-17T09:41:46.615Z" itemprop="datePublished">2019-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/17/位运算符/">位运算符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>位运算符是在数字底层（即表示数字的 32 个数位）进行操作的。<br>有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。<br><strong> 正数在计算机中使用原码的形式存储的，负数在计算机中是用补码的形式存储的。
</strong> 正数求原码直接将十进制转二进制即可，负数的补码是在源码的基础上除符号位外其余位取反后+1。</p>
<p>计算数字二进制补码的步骤有三步：</p>
<pre><code>确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）
求得二进制反码，即要把 0 替换为 1，把 1 替换为 0
在二进制反码上加 1
</code></pre><p>例如：要确定 -18 的二进制表示：<br>18 的二进制表示：0000 0000 0000 0000 0000 0000 0001 0010<br>计算二进制反码 ：1111 1111 1111 1111 1111 1111 1110 1101<br>二进制反码加 1： 1111 1111 1111 1111 1111 1111 1110 1110（-18的二进制表示）</p>
<h2 id="位运算NOT"><a href="#位运算NOT" class="headerlink" title="位运算NOT ~"></a>位运算NOT ~</h2><p>位运算 NOT 由否定号（ ~ ）表示<br>位运算 NOT 是三步的处理过程：<br>    把运算数转换成 32 位数字<br>    把二进制数转换成它的二进制反码<br>    把二进制数转换成浮点数<br>例如：<br>var iNum1 = 25;        //25 等于 00000000000000000000000000011001<br>var iNum2 =  ~ iNum1;    //转换为 11111111111111111111111111100110<br>alert(iNum2);        //输出 “-26”</p>
<p>位运算 NOT 实质上是对数字求负，然后减 1，因此 25 变 -26。</p>
<h2 id="位运算-AND-amp"><a href="#位运算-AND-amp" class="headerlink" title="位运算 AND &amp;"></a>位运算 AND &amp;</h2><p>位运算 AND 由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后按位计算。只有1 1才得到1.</p>
<h2 id="位运算-OR"><a href="#位运算-OR" class="headerlink" title="位运算 OR |"></a>位运算 OR |</h2><p>位运算 OR 由和号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，只有0 0 才得到0.</p>
<h2 id="位运算-XOR"><a href="#位运算-XOR" class="headerlink" title="位运算 XOR ^"></a>位运算 XOR ^</h2><p>位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。即两位不同才是1.</p>
<h2 id="左移运算"><a href="#左移运算" class="headerlink" title="左移运算"></a>左移运算</h2><p>左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）。<br>左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。</p>
<h2 id="有符号右移运算"><a href="#有符号右移运算" class="headerlink" title="有符号右移运算"></a>有符号右移运算</h2><p>有符号右移运算符由两个大于号表示（&gt;&gt;）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。<br>同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字。</p>
<h2 id="无符号右移运算"><a href="#无符号右移运算" class="headerlink" title="无符号右移运算"></a>无符号右移运算</h2><p>无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。<br>对于负数，情况就不同了。<br>无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/17/位运算符/" data-id="cjyedyp0s000e2ktejpy1ly68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数组遍历方法汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/24/数组遍历方法汇总/" class="article-date">
  <time datetime="2019-02-24T12:29:04.678Z" itemprop="datePublished">2019-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/24/数组遍历方法汇总/">数组遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach是数组的内置方法，但是无法中途跳出循环。遍历数组中的每一项，没有返回值，对原数组没有影响。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach((item,index,array)=&gt;&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>for in遍历的是数组的键名，会遍历手动添加的其他键，甚至包括原型链上的键。它是以字符串作为键名，为遍历对象而设计的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	console.log(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of ***"></a>for…of ***</h2><p>可以与break、continue和return配合使用，它提供了遍历所有数据结构的统一操作接口。它遍历的是键值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="keys，values，entries"><a href="#keys，values，entries" class="headerlink" title="keys，values，entries"></a>keys，values，entries</h2><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of arr.keys()) &#123;</span><br><span class="line">	console.log(key);</span><br><span class="line">&#125; // 0 1 2 </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr.values()) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125; // 1 4 3</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of arr.entries()) &#123;</span><br><span class="line">	console.log([key, value]);</span><br><span class="line">&#125; // [0, 1] [1, 4] [2, 3]</span><br></pre></td></tr></table></figure></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的回调函数中支持return返回值,不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="keyword">function</span>(value,index,array)&#123;</span><br><span class="line">　　//<span class="keyword">do</span> something</span><br><span class="line">　　<span class="built_in">return</span> XXX </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.map((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// [10,40,30]</span><br><span class="line">console.log(arr);// [1,4,3]</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>不会改变原始数组,返回新数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.filter((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// [4, 3]</span><br><span class="line">console.log(arr);// [1,4,3]</span><br></pre></td></tr></table></figure></p>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.every((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>如果该函数对任一项返回true，则返回true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.some((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce((previousValue, currentValue, index, array) =&gt; &#123;</span><br><span class="line"> <span class="built_in">return</span> previousValue + currentValue;// 根据需要修改</span><br><span class="line">&#125;， initialValue);</span><br></pre></td></tr></table></figure></p>
<p>initialValue参数可选，表示归并基础的初始值。</p>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p>reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>返回数组中符合测试函数条件的第一个元素。否则返回undefined 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.find((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// 4</span><br></pre></td></tr></table></figure></p>
<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p>对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].findIndex(<span class="keyword">function</span>(x) &#123; x == 2; &#125;);</span><br><span class="line">// Returns an index value of 1.</span><br></pre></td></tr></table></figure></p>
<p>并不是所有类似数组的结构都具有Iterator接口，但可以使用Array.from方法将其转为数组；<br>for…of遍历内部调用的是数据结构中的Symbol.iterator方法。</p>
<h2 id="数组的去重方法"><a href="#数组的去重方法" class="headerlink" title="数组的去重方法"></a>数组的去重方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const removeDuplicateItems = arr =&gt; &#123;<span class="built_in">return</span> [...new Set(arr)];&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [1,3,5,2,5,1];</span><br><span class="line"><span class="built_in">let</span> newArr = removeDuplicateItems(arr);</span><br><span class="line">console.log(arr);// [1, 3, 5, 2, 5, 1]</span><br><span class="line">console.log(newArr);// [1, 3, 5, 2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> uniq(array) &#123;</span><br><span class="line">    <span class="built_in">let</span> tmpArr = [];</span><br><span class="line">    array.forEach((value, index, array) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpArr.indexOf(value) == -1) &#123;</span><br><span class="line">            tmpArr.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> tmpArr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniq(arr));// [1, 3, 5, 2]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/24/数组遍历方法汇总/" data-id="cjyedyp0y000m2ktet43lnmy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-防抖和节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/22/防抖和节流/" class="article-date">
  <time datetime="2019-02-22T02:46:41.953Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/22/防抖和节流/">防抖和节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>附上学习连接<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5</a></p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间;<br>每次触发事件时都取消之前的延时调用方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">'inp'</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn) &#123;</span><br><span class="line">	<span class="built_in">let</span> timeout = null;// 创建一个标记用来存放定时器的返回值</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		clearTimeout(timeout);// 每当用户输入的时候把前一个setTimeout clear掉</span><br><span class="line">		timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">			fn.apply(this, arguments);</span><br><span class="line">		&#125;, 500);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayHi</span></span>() &#123;</span><br><span class="line">	console.log(<span class="string">'防抖成功'</span>);</span><br><span class="line">&#125;</span><br><span class="line">var inp = document.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi));</span><br></pre></td></tr></table></figure></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率;<br>每次触发事件时都判断当前是否有等待执行的延时函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throttle(fn) &#123;</span><br><span class="line">	<span class="built_in">let</span> canRun = <span class="literal">true</span>;// 通过闭包保存一个标记</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (!canRun) <span class="built_in">return</span>;</span><br><span class="line">		canRun = <span class="literal">false</span>; // 立即设置为<span class="literal">false</span></span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			fn.apply(this, arguments);</span><br><span class="line">			canRun = <span class="literal">true</span>;</span><br><span class="line">		&#125;, 500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> sayHi(e) &#123;</span><br><span class="line">	console.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, throttle(sayHi));</span><br></pre></td></tr></table></figure></p>
<p>函数节流和函数去抖的核心其实就是限制某一个方法被频繁触发，而一个方法之所以会被频繁触发，大多数情况下是因为 DOM 事件的监听回调，而这也是函数节流以及防抖多数情况下的应用场景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/22/防抖和节流/" data-id="cjyedyp14000t2ktelh3ubvwe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-渲染机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/11/渲染机制/" class="article-date">
  <time datetime="2019-01-11T03:02:23.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/11/渲染机制/">渲染机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器的渲染过程："><a href="#浏览器的渲染过程：" class="headerlink" title="浏览器的渲染过程："></a>浏览器的渲染过程：</h2><p><img src="/2019/01/11/渲染机制/浏览器渲染过程.png" alt="浏览器渲染过程"></p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>
</ol>
<h2 id="Load-和-DOMContentLoaded："><a href="#Load-和-DOMContentLoaded：" class="headerlink" title="Load 和 DOMContentLoaded："></a>Load 和 DOMContentLoaded：</h2><p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。<br>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待CSS，JS，图片加载。</p>
<h2 id="图层："><a href="#图层：" class="headerlink" title="图层："></a>图层：</h2><p>可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。<br>不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。<br>生成新图层的属性：</p>
<ol>
<li>3D 变换：translate3d、translateZ</li>
<li>will-change<br>例如想通知浏览器会发生一个transform方面的变化，可以这样写：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">	will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐的做法是当一个元素或属性发生变化时打开will-change，变化完成之后关闭它。</p>
<ol start="3">
<li>video、iframe 标签</li>
<li>通过动画实现的 opacity 动画转换</li>
<li>position: fixed</li>
</ol>
<h2 id="重绘（Repaint）和回流（Reflow）："><a href="#重绘（Repaint）和回流（Reflow）：" class="headerlink" title="重绘（Repaint）和回流（Reflow）："></a>重绘（Repaint）和回流（Reflow）：</h2><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘。<br>回流是布局或者几何属性需要改变就称为回流。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的。<br>例如，改变 window 大小，改变字体，添加或删除样式，定位或者浮动都会导致性能问题。</p>
<p>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。<br>会依次判断是否有 resize 或者 scroll，是否触发了 media query，更新动画，全屏操作事件，执行 requestAnimationFrame，执行 IntersectionObserver等等，然后更新界面。</p>
<p>减少重绘和回流的方法：</p>
<ol>
<li><p>使用 translate 替代 top</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-$(<span class="string">'.x'</span>).css(<span class="string">'top'</span>, <span class="string">'200px'</span>)</span><br><span class="line">+$(<span class="string">'.x'</span>).css(<span class="string">'translateY'</span>, <span class="string">'translateY(200px)'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）。</p>
</li>
<li>把 DOM 离线后（例如将DOM设置为display:none）再修改，改完后再将其显示出来。</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。</li>
<li>不要使用table，因为可能很小的一个小改动会造成整个 table 的重新布局。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/11/渲染机制/" data-id="cjyedyp11000q2kte0ucan51d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/10/存储/" class="article-date">
  <time datetime="2019-01-10T10:34:46.906Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/存储/">存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cookie，localStorage，sessionStorage，indexDB<br>Web Storage（Local Storage和Session Storage）使用简单字符串键值对在本地存储数据，方便灵活，但是不适于大量结构化数据存储。<br>indexDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。<br>对于简单的数据，应该使用localstorage，但当存储大量数据时，indexDB会更适合，indexDB能提供更为复杂的查询数据的方式。</p>
<p>浏览器端：<br>cookie<br>WebStorage(localStorage、sessionStorage)<br>userData：IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>indexedDB<br>服务器端：<br>session</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie由服务器生成，可以设置过期时间；第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。<br>数据存储大小是4k；<br>参与与服务端通信时，每次都会携带在header中，对于请求性能影响。<br>不建议用于存储。<br>对于cookie,需要注意安全问题：<br>1.value属性用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识；<br>2.http-only属性：若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。<br>从而减少XSS攻击。<br>3.secure属性：设置是否只能通过https来传递此条cookie；<br>4.same-site：规定浏览器不能在跨域请求中携带cookie，减少CSRF攻击。</p>
<p>适用场景：存储用户的登录信息</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage除非被清理，否则一直存在；<br>数据存储大小是5M；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">https://www.cnblogs.com/st-leslie/p/5617130.html</a><br>localStorage主要是用来作为本地存储来使用的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.优点：<br>localStorage拓展了cookie的4K限制，解决了cookie存储空间不足的问题，localStorage中一般浏览器支持的是5M大小。<br>localStorage可以将第一次请求的数据直接存储到本地。<br>2.局限：<br>localStorage的值类型限定为string类型，所以对我们JSON对象类型需要一些转换。<br>localStorage在浏览器的隐私模式下面是不可读取的。<br>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。<br>localStorage不能被爬虫抓取到。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>setItem(),getItem(),clear(),removeItem(),storage.keyName = value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!window.localStorage)&#123;</span><br><span class="line">    alert(<span class="string">"浏览器不支持localstorage"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    var storage = window.localStorage;</span><br><span class="line">    var data = &#123;</span><br><span class="line">    	name: <span class="string">'zxt'</span>,</span><br><span class="line">    	age: 23,</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"a"</span>,4);</span><br><span class="line">    storage.setItem(<span class="string">"b"</span>,5);</span><br><span class="line">    storage.setItem(<span class="string">"data"</span>,JSON.stringify(data));</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 4</span><br><span class="line">    storage.a = 7;// 修改值</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 7</span><br><span class="line">    storage.removeItem(<span class="string">"a"</span>);</span><br><span class="line">    // storage.clear();// 清除storage的所有内容</span><br><span class="line">    console.log(storage.key(0));// b 输入索引即可获取对应的键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用场景：<br>当用户欠费时，希望每个月给用户弹出一次提示框，用于提醒用户“已欠费”,那么用localStorage;<br>当用户欠费时，希望用户每次打开指定页面时弹出一次提示框，用于提醒用户“已欠费”,sessionStorage.</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage页面关闭就被清理；<br>数据存储大小是5M；<br>不参与与服务端通信。</p>
<p>localStorage与sessionStorage的区别是localStorage属于永久性存储，而sessionStorage属于当会话结束(例如页面关闭)的时候，sessionStorage中的键值对会被清空.</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>indexDB除非被清理，否则一直存在；<br>数据存储大小是无限的；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphinX/p/3415761.html</a><br>indexedDB是一个非关系型数据库系统,然而它是使用JavaScript对象,而不是列数固定的表格来存储数据的。<br>indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。</p>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>本质上充当应用程序和浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。旨在使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。<br>待学习~<br>站渐进式增强体验(PWA)改造：Service Worker 应用<br>Service Worker 最主要的特点是：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</p>
<p>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。<br><a href="http://lzw.me/a/pwa-service-worker.html" target="_blank" rel="noopener">http://lzw.me/a/pwa-service-worker.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/存储/" data-id="cjyedyp0w000k2ktevsoha49m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/22/决策树与随机森林/">决策树与随机森林</a>
          </li>
        
          <li>
            <a href="/2019/07/05/回归分析和朴素贝叶斯学习笔记/">回归分析和朴素贝叶斯学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/06/24/线性回归/">线性回归</a>
          </li>
        
          <li>
            <a href="/2019/06/20/CSS隐藏元素/">CSS隐藏元素</a>
          </li>
        
          <li>
            <a href="/2019/03/26/BFC/">BFC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>