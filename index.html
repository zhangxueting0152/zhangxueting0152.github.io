<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/promise/" class="article-date">
  <time datetime="2019-01-07T01:48:20.573Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/promise/">promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。</p>
<h2 id="promise含义"><a href="#promise含义" class="headerlink" title="promise含义"></a>promise含义</h2><p>1.Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>2.Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就固定，不会再变了，会一直保持这个结果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	console.log(<span class="string">'Promise'</span>);</span><br><span class="line">	<span class="function"><span class="title">if</span></span>() &#123;</span><br><span class="line">		resolve(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reject(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">	// success</span><br><span class="line">	&#125;,error =&gt; &#123;</span><br><span class="line">	// failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1.promise的构造函数接受一个函数作为参数，这个函数有两个参数分别是resolve和reject。而resolve和reject又各自是两个函数。<br>resolve函数，当Promise对象的状态从 pending 变为 resolved，在异步操作成功时调用，并将异步操作的结果作为参数value传递出去。<br>reject函数，当Promise对象的状态从pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误value,作为参数传递出去。<br>2.then方法的参数是两个回调函数：<br>第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数(可选)是Promise对象的状态变为rejected时调用。第二个参数是可选的。<br>then可以采用链式写法。<br>3.Promise 新建后就会立即执行。即回立马输出Promise。<br>4.Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<h2 id="resolve的参数是promise对象时："><a href="#resolve的参数是promise对象时：" class="headerlink" title="resolve的参数是promise对象时："></a>resolve的参数是promise对象时：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure>
<p>执行代码，p1是一个Promise,3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。<br>因此，后面的then语句变成针对P1。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<h2 id="Promise-prototype-finally-："><a href="#Promise-prototype-finally-：" class="headerlink" title="Promise.prototype.finally()："></a>Promise.prototype.finally()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;&#125;)</span><br><span class="line">.finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<h2 id="Promise-all-："><a href="#Promise-all-：" class="headerlink" title="Promise.all()："></a>Promise.all()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>p的状态由p1、p2、p3决定，分为两种情况。<br>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。<br>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
<h2 id="Promise-race-："><a href="#Promise-race-：" class="headerlink" title="Promise.race()："></a>Promise.race()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h2 id="Promise-resolve-："><a href="#Promise-resolve-：" class="headerlink" title="Promise.resolve()："></a>Promise.resolve()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象</p>
<p>Promise.resolve(‘foo’); &lt;==&gt; new Promise(resolve =&gt; resolve(‘foo’));</p>
<h2 id="构造函数和原型上的方法"><a href="#构造函数和原型上的方法" class="headerlink" title="构造函数和原型上的方法"></a>构造函数和原型上的方法</h2><p>1.<br>Promise.prototype.then()，Promise.prototype.catch()，Promise.prototype.finally();<br>Promise.all()，Promise.race()，Promise.resolve()，Promise.reject()，Promise.try();</p>
<p>2.在Promise构造函数上实现的all，race，reject，resolve，不能在对象的实例中访问，属于Promise构造函数自己，这样做保证了对象的命名空间整洁。所以这几个函数的调用方式是Promise.all()，Promise.race()，Promise.reject()，Promise.resolve()。</p>
<p>3.在构造函数原型上实现then，catch的方法是为了让Promise构造函数创建的实例共享then，catch方法。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.异步加载图片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loadImageAsync(url) &#123;</span><br><span class="line">	<span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		const image = new Image();</span><br><span class="line">		image.onload = () =&gt; resolve(image); </span><br><span class="line">		image.onerror = () =&gt; reject(new Error(<span class="string">'图片加载失败'</span>));</span><br><span class="line">		image.src = url;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.实现一个简单的promise<br><a href="https://segmentfault.com/a/1190000009792439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009792439</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyPromise(fn) &#123;</span><br><span class="line">	this._status = <span class="string">'pending'</span>;</span><br><span class="line">	this._value = undefined;</span><br><span class="line">	this._onResolvedCallback = [];</span><br><span class="line">	this._onRejectCallback = [];</span><br><span class="line">	fn(resolve.bind(this), reject.bind(this));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> resolve(value) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'resolved'</span>;</span><br><span class="line">		this._value = value;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onResolvedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> reject(reason) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'reject'</span>;</span><br><span class="line">		this._value = reason;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onRejectedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="keyword">function</span>(onResolved, onRejected) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	var promise2;</span><br><span class="line">	onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="keyword">function</span>(v) &#123;&#125;;</span><br><span class="line">	onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="keyword">function</span> (r) &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(self._status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">		<span class="built_in">return</span> promise = new MyPromise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				 var x = onResolved(self._value);</span><br><span class="line">				 <span class="keyword">if</span>(x instanceof MyPromise) &#123;</span><br><span class="line">				 	x.then(resolve, reject);</span><br><span class="line">				 &#125;</span><br><span class="line">				 resolve(x);</span><br><span class="line">			&#125; catch(e) &#123;</span><br><span class="line">				reject(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (self._status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">	    <span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">	      try &#123;</span><br><span class="line">	        var x = onRejected(self._value)</span><br><span class="line">	        <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">	          x.then(resolve,reject)</span><br><span class="line">	        &#125;</span><br><span class="line">	      &#125; catch(e) &#123;</span><br><span class="line">	        reject(e)</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(self._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">  	<span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  		self._onResolvedCallback.push(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          var x = onResolved(self._value)</span><br><span class="line">          <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self._onRejectCallback.push(<span class="keyword">function</span>(reason) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x =onRejected(self._value)</span><br><span class="line">          <span class="keyword">if</span>(x instanceof Promise) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//<span class="built_in">test</span> code</span><br><span class="line">  var myFirstPromise = new MyPromise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          resolve(<span class="string">"成功!"</span>); //代码正常执行！</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  myFirstPromise.then(<span class="keyword">function</span> (successMessage) &#123;</span><br><span class="line">     console.log(<span class="string">"Yay! "</span> + successMessage);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/promise/" data-id="cjqm2qopp0003xctemvuf2ktd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-macrotask microtask" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/macrotask microtask/" class="article-date">
  <time datetime="2019-01-05T02:02:14.058Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/macrotask microtask/">macrotask microtask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>macrotask翻译过来，是宏任务的意思，我们常说的任务队列就指的是macrotask；<br>microtask翻译过来，是微任务的意思</p>
<p>js是单线程的，意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务。因此，将所有的任务分成两种，一种是同步任务synchronous，另一种是异步任务asynchronous。<br>同步任务指的是在主线程上排队执行的任务，也就是平常所说的执行队列，这个里面的任务必须要个按照次序依次执行，只有前一个执行完了，才可以执行下一个。<br>异步任务指的是不进入主线程，而进入“任务队列”task queue的任务，只有当“任务队列”通知主线程某个异步任务可以执行了，该任务才可以进入主线程执行。异步任务执行的时候，执行的就是定义的回调函数。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br>异步执行的运行机制如下：<br>1.所有同步任务都是在主线程上执行，形成一个执行栈execution context stack。<br>2.主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。<br>3.一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4.主线程不断重复上面的第三步。</p>
<h2 id="macrotask-microtask"><a href="#macrotask-microtask" class="headerlink" title="macrotask microtask"></a>macrotask microtask</h2><p>macrotask和microtask都属于上述的异步任务中的一种，其中：<br>macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering，requestAnimationFrame；<br>microtasks: process.nextTick, Promise, MutationObserver，Object.observe；<br>microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务，例如响应时间，以避免付出额外的一个task代价。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>macrotask就是常说的任务队列task queue。<br>js执行顺序如下：<br>开始 -&gt; 取任务队列的第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取任务队列的第一个task执行 -&gt; 取microtask全部任务依次执行…循环往复<br>直到两个队列全部任务执行完毕</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">let</span> p1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">  console.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'Promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then((res)=&gt;&#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line">//Promise1 1 Promise2 setTimeout</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>整个script代码，放在了macrotask queue中,执行到setTimeout时会新建一个macrotask queue，promise.then放到了另一个microtask queue中。<br>script的执行引擎会取1个macrotask queue中的task，执行之。<br>然后把所有microtask queue顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(1);&#125;, 0);</span><br><span class="line">console.log(2);</span><br><span class="line">//2 1</span><br></pre></td></tr></table></figure>
<p>因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/macrotask microtask/" data-id="cjqm2qopo0002xctezjyu1fet" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/19/this学习/" class="article-date">
  <time datetime="2018-12-19T07:30:07.000Z" itemprop="datePublished">2018-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/19/this学习/">this学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么会出现this问题？"><a href="#为什么会出现this问题？" class="headerlink" title="为什么会出现this问题？"></a>为什么会出现this问题？</h2><p>参考链接：<a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/06/javascript-this.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	bar: 1,</span><br><span class="line">	foo: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		console.log(this.bar);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var foo = obj.foo;</span><br><span class="line">var bar = 2;</span><br><span class="line">obj.foo();//1</span><br><span class="line">foo();//2</span><br></pre></td></tr></table></figure></p>
<p>出现这种情况的原因是，this指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以this指向obj;但是对于foo()来说是运行在全局环境中，所以this指向全局环境，即window.</p>
<h3 id="js内存的数据结构"><a href="#js内存的数据结构" class="headerlink" title="js内存的数据结构"></a>js内存的数据结构</h3><p>1.当属性的值是一个数值的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于这段代码，js引擎会首先在内存里面生成一个对象{ foo:  5 }，然后把该对象的地址赋值给obj。<br>原始的对象是以字典的形式保存的，每一个属性名都对应一个对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 5</span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/19/this学习/属性值是数值.png" alt="属性值是数值"></p>
<p>2.当属性的值是一个函数的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="function"><span class="title">function</span></span> () &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个时候在内存中会存在一个函数，并且将这个函数的地址赋值给foo属性的value属性。<br><img src="/2018/12/19/this学习/属性值是函数.png" alt="属性值是函数"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正是由于函数是一个单独的值，所以它可以在不同的环境（上下文）中执行。那么就需要一种机制，可以在函数内部获得当前的运行环境（上下文），这个机制就是this.它的存在就是表示函数的当前运行环境。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  foo: f,</span><br><span class="line">  x: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f() // 1</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f() // 2</span><br></pre></td></tr></table></figure>
<p>1.图形解释f()结果:<br><img src="/2018/12/19/this学习/f结果.png" alt="f()结果"><br>2.图形解释obj.f()结果:<br><img src="/2018/12/19/this学习/obj.f结果.png" alt="obj.f()结果"></p>
<p>那么此时就明白了：对于obj.foo()来说，是通过obj找到foo，所以就是在obj环境中执行的；<br>但是对于var foo = obj.foo;，那么变量foo就直接指向函数本身，所以此时foo()就变成是在全局环境中执行的。</p>
<h2 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h2><h3 id="全局环境："><a href="#全局环境：" class="headerlink" title="全局环境："></a>全局环境：</h3><p>在全局环境下，无论是否是严格模式，this始终指向全局对象window</p>
<h3 id="函数上下文调用："><a href="#函数上下文调用：" class="headerlink" title="函数上下文调用："></a>函数上下文调用：</h3><p>1.函数直接调用时：<br>非严格模式下，this指向全局对象window；严格模式下，this为undefined.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">console.log(f1() === window) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">  <span class="string">"use strict"</span>; // 这里是严格模式</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">console.log(f2() === undefined) // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>2.对象中的this：<br>依照下面的法则去替换即可：（谁调用它，this就指向谁）<br>foo() —&gt; foo.call(window)<br>obj.foo() –&gt; obj.foo.call(obj)</p>
<p>3.构造函数的this<br>构造函数中的this与被创建的新对象绑定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">C</span></span>()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  <span class="built_in">return</span> &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var b = new C();</span><br><span class="line">console.log(b.a); //38</span><br></pre></td></tr></table></figure></p>
<p>4.call &amp; apply和bind方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(c, d)&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tt</span></span>() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">tt.call(5);  // Number &#123;[[PrimitiveValue]]: 5&#125; </span><br><span class="line">tt.call(<span class="string">'asd'</span>); // String &#123;0: <span class="string">"a"</span>, 1: <span class="string">"s"</span>, 2: <span class="string">"d"</span>, length: 3, [[PrimitiveValue]]: <span class="string">"asd"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>bind方法，会将函数永远绑定在其第一个参数对象上，无论在什么情况下被调用，它的this指向都不变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a;</span><br><span class="line">&#125;</span><br><span class="line">var g = f.bind(&#123;a:<span class="string">"azerty"</span>&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure></p>
<p>5.DOM事件处理函数中的this<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"myBtn"</span> onclick=<span class="string">"test()"</span>&gt;click&lt;/button&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> listenerTest(e)&#123;</span><br><span class="line">      console.log(this);//输出&lt;button id=<span class="string">"myBtn"</span> onclick=<span class="string">"test()"</span>&gt;click&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(<span class="string">"myBtn"</span>).addEventListener(<span class="string">'click'</span>, listenerTest, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">      //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames:Window, listenerTest:ƒ listenerTest(e)…&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(document.getElementById(<span class="string">"myBtn"</span>).onclick);//ƒ onclick(event) &#123;<span class="built_in">test</span>()&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>我对上述代码的控制台输出的理解：<br>因为listenerTest方法是绑定到button对象上，所以里面的this指向button;<br>而test方法是赋给了onclick属性，点击时，是window调用的test方法，所以打印出来的是window，并且可以看到在window里有listenerTest方法。点击时，是执行了window.onclick()方法，只不过onclick()里调用了test()函数。</p>
<p>5.1 当函数被当作监听事件处理函数（addEventListen）时，其中的this指向触发该事件的元素。<br>5.2 当代码被内联函数调用时，this指向监听器所在的DOM元素；当代码被包括在函数内部执行时，this指向全局对象window或者undefined.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"console.log(this);"</span>&gt;click&lt;/button&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"(function() &#123;console.log(this)&#125;)();"</span>&gt;show inner&lt;/button&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"(function() &#123;'use strict';console.log(this)&#125;)();"</span>&gt;use strict&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>依次点击这三个按钮后，控制台输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"console.log(this);"</span>&gt;click&lt;/button&gt;</span><br><span class="line">Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p>
<p>6.setTimeout &amp; setInterval<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).<span class="built_in">bind</span>(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person &#123;age: 0&#125;</span><br></pre></td></tr></table></figure>
<p>7.箭头函数中的this<br>7.1 箭头函数在方法内部<br>箭头函数会自己捕获所在的上下文的this值，即定义的位置。call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对this毫无影响。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person &#123;age: 0&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : <span class="keyword">function</span>(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    <span class="built_in">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="keyword">function</span> inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(adder.add(1));         //2</span><br><span class="line">console.log(adder.addThruCall(1)); //2</span><br></pre></td></tr></table></figure>
<p>7.2 作为方法的箭头函数<br>作为方法的箭头函数的this指向全局对象window,而普通函数则指向调用它的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  arrow: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.arrow();  //undefined Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br><span class="line">obj.c(); //10 &#123;i: 10, arrow: ƒ, c: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>学习参考链接：<br><a href="http://www.imooc.com/article/1758" target="_blank" rel="noopener">http://www.imooc.com/article/1758</a><br><a href="http://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongcanliang/p/7054176.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/19/this学习/" data-id="cjqm2qopr0005xctesu0mb4gg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包和立即执行函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/18/闭包和立即执行函数/" class="article-date">
  <time datetime="2018-12-18T01:54:17.096Z" itemprop="datePublished">2018-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/18/闭包和立即执行函数/">闭包和立即执行函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包closure"><a href="#闭包closure" class="headerlink" title="闭包closure"></a>闭包closure</h2><p>闭包的定义就是：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被成为闭包。</p>
<h3 id="为什么会有闭包的出现？"><a href="#为什么会有闭包的出现？" class="headerlink" title="为什么会有闭包的出现？"></a>为什么会有闭包的出现？</h3><p>假设现在有一个需求：想定义一个变量，使得计数的时候可以加1。<br>最直接想到的代码为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i=0;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">console.log(i);//1</span><br></pre></td></tr></table></figure></p>
<p>但是全局变量i有风险，因为可能不小心在哪里就改掉它了，但是用局部变量的话，它就只能在函数内部有效，调用完函数后它就没了，而且全局没法使用。所以现在的需求就是想让这个计数器可以在全局使用，但又不能被随便修改。此时闭包就要出场了~</p>
<h3 id="什么是闭包函数？"><a href="#什么是闭包函数？" class="headerlink" title="什么是闭包函数？"></a>什么是闭包函数？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = add();</span><br><span class="line">console.log(a1());//1</span><br><span class="line">console.log(a1());//2</span><br><span class="line"></span><br><span class="line">var a2 = add();</span><br><span class="line">console.log(a2());//1</span><br></pre></td></tr></table></figure>
<p>每次调用add()函数后会生成一个计数器，而且不同的计数器之间是不干扰的。<br>我们不能自己操控变量i，但是可以通过特定的方法“add中返回的匿名函数”去操作它。</p>
<p>总结一下，闭包函数最大的特点就是：创建内部变量，使得这些变量不能被外部随意修改，然后只能通过特定的方法才可以访问操作它。</p>
<p>对于有多个特定方法可以操作变量时，可以考虑下述写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">count</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">minus</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> --i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> &#123;</span><br><span class="line">		outerAdd: add,</span><br><span class="line">		outerMinus: minus</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var count1 = count();</span><br><span class="line">console.log(count1.outerAdd());//1</span><br><span class="line">console.log(count1.outerMinus());//0</span><br></pre></td></tr></table></figure></p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><h3 id="为什么会有立即函数的出现？"><a href="#为什么会有立即函数的出现？" class="headerlink" title="为什么会有立即函数的出现？"></a>为什么会有立即函数的出现？</h3><p>在闭包的基础上，现在又有这样的需求：就是我们希望对象只有一份，不像上部分中既有a1又有a2，类似后端中的单例模式。那么我们想到的解决思路就是保证这个方法只能被调用一次。<br>首先因为不能多次调用，那么就需要是匿名的；然后因为只能被调用一次，那么必须在声明的时候立马执行。这个时候就出现了立即执行函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var count1 = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	var i=0;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="function"><span class="title">minus</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> --i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> &#123;</span><br><span class="line">		outerAdd: add,</span><br><span class="line">		outerMinus: minus</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(count1.outerAdd());//1</span><br><span class="line">console.log(count1.outerAdd());//2</span><br><span class="line">console.log(count1.outerMinus());//1</span><br></pre></td></tr></table></figure>
<p>count1就是这个匿名函数返回的一个对象，该对象有两个属性：outerAdd和outerMinus，每个属性分别对应一个函数的定义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/18/闭包和立即执行函数/" data-id="cjqm2qoq3000excteshjkmii8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-异步，同步，回调和class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/异步，同步，回调和class/" class="article-date">
  <time datetime="2018-12-05T03:18:44.947Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/异步，同步，回调和class/">异步，同步，回调和js的class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉阮一峰对异步，同步和回调的解释，很通俗，所以在这里记一下.<br>链接：<a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator-async</a></p>
<h2 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h2><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。<br>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<h2 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h2><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h2 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h2><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。</p>
<h2 id="class："><a href="#class：" class="headerlink" title="class："></a>class：</h2><p>ES6 的类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注：<br>类里面会用到super关键字，super这个关键字，既可以当作函数使用，也可以当作对象使用。第一种情况，super作为函数调用时，代表父类的构造函数。第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/05/异步，同步，回调和class/" data-id="cjqm2qoq2000dxcte5j7q1z2h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/深浅拷贝/" class="article-date">
  <time datetime="2018-11-28T10:43:19.199Z" itemprop="datePublished">2018-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/28/深浅拷贝/">深浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章记录一下对浅拷贝和深拷贝的理解。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var me = &#123;name:<span class="string">"zxt"</span>&#125;</span><br><span class="line">//浅拷贝</span><br><span class="line">var brother = me;</span><br><span class="line">brother.name = <span class="string">"brother"</span>;</span><br><span class="line">console.log(me.name);//brother</span><br></pre></td></tr></table></figure>
<p>因为me对象里在栈内存中存的是一个地址，该地址指向位于堆内存中的一个对象{name:”zxt”}。所以通过浅拷贝，brother里面也存的是地址，也就是说brother和me指向了同一个地方，<br>因此修改brother里的name属性会对me产生影响。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="1-一层slice-和concat"><a href="#1-一层slice-和concat" class="headerlink" title="1.一层slice()和concat()"></a>1.一层slice()和concat()</h3><p>数组的slice()方法：返回从原数组中指定下标到结束下标之间的项组成的新数组，不包含结束位置的项。<br>数组的concat()方法：将参数添加到原数组中。这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">var arrShallow = arr;</span><br><span class="line">var arrSlice = arr.slice(0);</span><br><span class="line">var arrConcat = arr.concat();</span><br><span class="line"></span><br><span class="line">console.log(arr === arrShallow);//<span class="literal">true</span></span><br><span class="line">console.log(arr === arrSlice);//<span class="literal">false</span></span><br><span class="line">console.log(arr === arrConcat);//<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,[2,2],3];</span><br><span class="line">var arrShallow = arr;</span><br><span class="line">var arrSlice = arr.slice(0);</span><br><span class="line">var arrConcat = arr.concat();</span><br><span class="line"></span><br><span class="line">arr[1][0] = 6;</span><br><span class="line">arr[0] = 8;</span><br><span class="line">console.log(arr);//[8,[6,2],3]</span><br><span class="line">console.log(arrShallow);//[8,[6,2],3]</span><br><span class="line">console.log(arrSlice);//[1,[6,2],3]</span><br><span class="line">console.log(arrConcat);//[1,[6,2],3]</span><br></pre></td></tr></table></figure>
<p>可以看到，slice()和concat()没有执行真正的深拷贝，当数组中存放的还是一个数组或者对象时，也是只复制了引用。</p>
<h3 id="2-一层Object-assign"><a href="#2-一层Object-assign" class="headerlink" title="2.一层Object.assign()"></a>2.一层Object.assign()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;age: 1&#125;;</span><br><span class="line"><span class="built_in">let</span> b = Object.assign(&#123;&#125;, a);</span><br><span class="line">a.age = 2;</span><br><span class="line">console.log(b.age);//1</span><br></pre></td></tr></table></figure>
<h3 id="3-JSON-parse-和JSON-stringify"><a href="#3-JSON-parse-和JSON-stringify" class="headerlink" title="3.JSON.parse()和JSON.stringify()"></a>3.JSON.parse()和JSON.stringify()</h3><p>JSON.parse():从一个字符串中解析出json对象<br>JSON.stringify():从一个对象中解析出字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data1 = <span class="string">'&#123;"name":"zxt"&#125;'</span>;</span><br><span class="line">console.log(JSON.parse(data1));//&#123;name: <span class="string">"zxt"</span>&#125;注意这个name没有加引号</span><br><span class="line"></span><br><span class="line">var data2 = &#123;<span class="string">"name"</span>:<span class="string">"zxt"</span>&#125;;</span><br><span class="line">console.log(JSON.stringify(data2));//&#123;<span class="string">"name"</span>:<span class="string">"zxt"</span>&#125;注意这个name加了引号</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var me = [1,[2,2],3];</span><br><span class="line">var brother = JSON.parse(JSON.stringify(me));</span><br><span class="line">me[1][0] = 6;</span><br><span class="line">me[0] = 8;</span><br><span class="line">console.log(me);//[8,[6,2],3]</span><br><span class="line">console.log(brother);//[1,[2,2],3]</span><br></pre></td></tr></table></figure>
<p>该方法对数据的类型由要求限制，必须是能用json方法的格式。</p>
<h3 id="4-jQuery中的extend"><a href="#4-jQuery中的extend" class="headerlink" title="4.jQuery中的extend"></a>4.jQuery中的extend</h3><p>jQuery.extend() 函数用于将一个或多个对象的内容合并到目标对象。<br>$.extend( [deep ], target, object1 [, objectN ] ) :<br>deep:可选。 Boolean类型 指示是否深度合并对象，默认为false。<br>target:Object类型 目标对象，其他对象的成员属性将被附加到该对象上。<br>objectN: 可选。 Object类型 第N个被合并的对象。<br>这个链接分析了jQuery中的extend的实现原理，并且自己实现了一个深拷贝，记录一下，方便以后学习：<a href="https://www.cnblogs.com/tracylin/p/5346314.html" target="_blank" rel="noopener">https://www.cnblogs.com/tracylin/p/5346314.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var me = [1,[2,2],3];</span><br><span class="line">var brother = [];</span><br><span class="line">$.extend(brother,me);</span><br><span class="line">me[1][0] = 6;</span><br><span class="line">me[0] = 8;</span><br><span class="line">console.log(me);//[8,[6,2],3]</span><br><span class="line">console.log(brother);//[1,[6,2],3]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var me = [1,[2,2],3];</span><br><span class="line">var brother = [];</span><br><span class="line">$.extend(<span class="literal">true</span>,brother,me);</span><br><span class="line">me[1][0] = 6;</span><br><span class="line">me[0] = 8;</span><br><span class="line">console.log(me);//[8,[6,2],3]</span><br><span class="line">console.log(brother);//[1,[2,2],3]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/28/深浅拷贝/" data-id="cjqm2qoqf000gxcteiisgm32f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端面试题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/27/前端面试题记录/" class="article-date">
  <time datetime="2018-11-27T02:55:06.212Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/27/前端面试题记录/">前端面试题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇博客是对网页上前端问题的答案记录：<a href="https://mp.weixin.qq.com/s/uVZnt6HMs2b9-rPxqkZ-bQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uVZnt6HMs2b9-rPxqkZ-bQ</a><br>在网上有看到别人的答案链接，在这里记录一下地址：<a href="https://ryuurock.com/2018/11/25/frontend-interview/#undefined" target="_blank" rel="noopener">https://ryuurock.com/2018/11/25/frontend-interview/#undefined</a></p>
<h2 id="基本的JS问题"><a href="#基本的JS问题" class="headerlink" title="基本的JS问题"></a>基本的JS问题</h2><h3 id="1-让下面的代码可以运行"><a href="#1-让下面的代码可以运行" class="headerlink" title="1.让下面的代码可以运行"></a>1.让下面的代码可以运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [1, 2, 3, 4, 5];</span><br><span class="line">// Implement this</span><br><span class="line">a.multiply();</span><br><span class="line">console.log(a); // [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>
<p>答：<br>这道题的思路就是给数组原型上添加一个方法，叫multiply<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.multiply = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	<span class="built_in">let</span> length = this.length;</span><br><span class="line">	//不能在<span class="keyword">for</span>循环里写i&lt;this.length，因为this的长度一直在加长，这样会内存溢出</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">let</span> i=0; i&lt;length; i++) &#123;</span><br><span class="line">		this.push(this[i]*this[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunction();</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>()&#123;</span><br><span class="line">	const a = [1,2,3,4,5];</span><br><span class="line">	a.multiply();</span><br><span class="line">	console.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以用es6的写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.multiply = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	<span class="built_in">let</span> result = this;</span><br><span class="line">	this.forEach(item =&gt; result.push(item*item));//或者写this.push(item*item)</span><br><span class="line">	<span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">myFunction();</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>()&#123;</span><br><span class="line">	const a = [1,2,3,4,5];</span><br><span class="line">	a.multiply();</span><br><span class="line">	console.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-以下代码会返回false，解释为什么会这样："><a href="#2-以下代码会返回false，解释为什么会这样：" class="headerlink" title="2.以下代码会返回false，解释为什么会这样："></a>2.以下代码会返回false，解释为什么会这样：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="literal">false</span></span><br><span class="line">0.2 + 0.1 === 0.3</span><br></pre></td></tr></table></figure>
<p>答：<br>ES6在Number对象上面，新增了一个极小的常量Number.EPSILON，表示1与大于1的最小浮点数之间的差。<br>对于64位浮点数来说，这个值相当于2的-52次方，是js能够表示的最小精度。误差如果小于这个值，就可以认为不存在误差了。<br>引入这个值的目的，在于为浮点数计算设置一个误差范围，毕竟浮点数的计算是不准确的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.EPSILON === Math.pow(2, -52));//<span class="literal">true</span></span><br><span class="line">console.log(Number.EPSILON);//2.220446049250313e-16</span><br><span class="line">//toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字</span><br><span class="line">console.log(Number.EPSILON.toFixed(20));//0.00000000000000022204</span><br><span class="line"></span><br><span class="line">console.log(0.1 + 0.2);//0.30000000000000004</span><br><span class="line">console.log(0.1 + 0.2 - 0.3);//5.551115123125783e-17</span><br><span class="line">console.log(5.551115123125783e-17.toFixed(20));//0.00000000000000005551</span><br></pre></td></tr></table></figure></p>
<h3 id="3-JavaScript-中有哪些不同的数据类型？"><a href="#3-JavaScript-中有哪些不同的数据类型？" class="headerlink" title="3.JavaScript 中有哪些不同的数据类型？"></a>3.JavaScript 中有哪些不同的数据类型？</h3><p>答：<br>分为基本数据类型和引用数据类型：<br>基本数据类型:Number String Boolean Undefined Null Symbol(表示独一无二的值)；基本数据类型是按值访问的，可以直接操作保存在变量中的实际值。<br>引用数据类型Object(包括Object,Date.Array,Function)；引用数据类型只能操作对象在栈内存中的引用地址。</p>
<h3 id="7-“new”关键字在-JavaScript-中有什么作用？"><a href="#7-“new”关键字在-JavaScript-中有什么作用？" class="headerlink" title="7.“new”关键字在 JavaScript 中有什么作用？"></a>7.“new”关键字在 JavaScript 中有什么作用？</h3><p>答：在js中，new是用于实例化对象的运算符。js中new一个对象会做四件事：<br>例如var obj = new Base();<br>7.1 var obj = {};<br>7.2 obj.-proto- = Base.prototype;<br>7.3 Base.call(obj);<br>7.4 return<br>文字说明一下这四步：<br>7.1 创建一个空对象obj；<br>7.2 将这个空对象的-proto-成员指向了Base函数对象的prototype成员对象；<br>7.3 将Base函数对象的this指针换成obj，然后再调用Base函数；<br>7.4 返回该对象。</p>
<h3 id="8-JavaScript-中有哪些不同的函数调用模式？请详细解释。"><a href="#8-JavaScript-中有哪些不同的函数调用模式？请详细解释。" class="headerlink" title="8.JavaScript 中有哪些不同的函数调用模式？请详细解释。"></a>8.JavaScript 中有哪些不同的函数调用模式？请详细解释。</h3><p>答：五种调用模式：直接调用，函数调用，方法调用，构造器调用，call和apply调用。<br>8.1 直接调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myFun1</span></span>() &#123;</span><br><span class="line">	console.log(<span class="string">"myFun1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">myFun1();//myFun1</span><br></pre></td></tr></table></figure></p>
<p>8.2 函数调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var myFun2 = <span class="keyword">function</span>(a) &#123;</span><br><span class="line">	var a = 2;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">myFun2(2);//1</span><br></pre></td></tr></table></figure></p>
<p>8.3 作为对象的方法调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">	name: <span class="string">'zhangsan'</span>,</span><br><span class="line">	myFun3: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		console.log(<span class="string">"myFun3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.myFun3();//myFun3</span><br></pre></td></tr></table></figure></p>
<p>8.4 构造器调用模式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">obj.prototype.myFun4 = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	console.log(<span class="string">"myFun4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var objItem = new obj();</span><br><span class="line">objItem.myFun4();//myFun4</span><br></pre></td></tr></table></figure></p>
<p>8.5 通过call,apply调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var myFun5 = <span class="keyword">function</span>(a) &#123;</span><br><span class="line">	<span class="built_in">return</span> a+1;</span><br><span class="line">&#125;</span><br><span class="line">var item1 = myFun5.call(obj,5);</span><br><span class="line">var item2 = myFun5.apply(obj,[5]);</span><br><span class="line">console.log(item1,item2);//6 6</span><br></pre></td></tr></table></figure></p>
<h2 id="JavaScript-前端应用程序设计问题"><a href="#JavaScript-前端应用程序设计问题" class="headerlink" title="JavaScript 前端应用程序设计问题"></a>JavaScript 前端应用程序设计问题</h2><h3 id="1-解释单向数据流和双向数据绑定"><a href="#1-解释单向数据流和双向数据绑定" class="headerlink" title="1.解释单向数据流和双向数据绑定"></a>1.解释单向数据流和双向数据绑定</h3><p>答：<br>单项数据流：指数据只能从一个方向修改数据，例如react中，父组件可以向子组件中传递数据data，当父组件中改变data的值，子组件的data值就会跟着改变；但是反过来，在子组件中对data修改后，父组件的值并不会发生改变。React、Vue等基于单向数据流。<br>双向数据绑定：主要是由mvvm框架实现，例如在vue中由三个部分组成：view,viewmodel,model，其中view和model要通过viewmodel进行通讯。当model部分数据发生改变时，viewmodel通知view更新视图；当view数据发生变化时也会同步到model中。Angular 1.x 基于双向数据绑定。<br>react的双向数据绑定是通过event.target.value实现的。<br>vue的双向数据绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。它使用MVVM框架，使用了v-model。其基于Object.defineProperty()方法，重新定义了对象获取属性值get和设置属性值set的操作来实现的。原理及实现的参考链接在这里记录一下，方便以后学习：<a href="http://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener">http://www.cnblogs.com/canfoo/p/6891868.html</a><br>单项数据绑定的实现思路是：所有数据只有一份；一旦数据发生变化，就会更新页面（data-页面），但是不存在（页面-data）;如果用户在页面上做了变动，那么就手动收集起来（双向绑定的话就会自动收集），合并到原有数据中。所以说双向数据绑定=单项绑定+事件监听。</p>
<h2 id="前端基础和理论相关问题"><a href="#前端基础和理论相关问题" class="headerlink" title="前端基础和理论相关问题"></a>前端基础和理论相关问题</h2><h3 id="1-HTML-中-Doctype-的用途是什么？"><a href="#1-HTML-中-Doctype-的用途是什么？" class="headerlink" title="1.HTML 中 Doctype 的用途是什么？"></a>1.HTML 中 Doctype 的用途是什么？</h3><p>对于以下每种情况，将会发生什么：<br>1.1 Doctype 不存在<br>1.2 使用 HTML4 Doctype，但 HTML 页面使用了 HTML5 标签<br>1.3 使用了无效的 Doctype</p>
<p>答：HTML 中 Doctype是告知浏览器用什么标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。其拥有如下特点：<br>声明必须在html文档的头部，在<html>标签前。在html5中不区分大小写；<br>&lt;!DOCTYPE&gt;不是一个标签，该声明指示web浏览器关于页面使用哪个HTML版本进行编写的指令；<br>在html4中该声明指向一个DTD，由于HTML4.01基于SGML（标准通用标记语言），所以DTD指定了标记规则以保证浏览器正确渲染内容。HTML5不基于SGML，所以不用指定DTD。<br>HTML5只有一种声明: &lt;!DOCTYPE html&gt;<br>HTML4.01有三种声明：strict, transitional, frameset。</html></p>
<h3 id="2-DOM-和-BOM-有什么区别？"><a href="#2-DOM-和-BOM-有什么区别？" class="headerlink" title="2.DOM 和 BOM 有什么区别？"></a>2.DOM 和 BOM 有什么区别？</h3><p>答：<br>2.1 DOM（文档对象模型），用来获取或者设置文档中标签的属性，其操作对象是文档。因为当一个html页面加载到浏览器的时候，浏览器会为每个标签都创建一个对应的对象描述该标签的所有信息。<br>2.2 BOM（浏览器对象模型），用来获取或者设置浏览器的属性和行为。例如<br>window表示当前的窗口，常用的方法有open(),moveTo(),setInterval(),setTimeout()，alert()；<br>location表示地址栏对象，常用的方法有href,reload();<br>screen表示屏幕对象，常用方法有height,width；</p>
<p>注：javascript由三部分组成：ECMAScript描述了该语言的语法和基本对象，可以理解为是javascript的一个标准；DOM描述处理网页内容和方法的接口；BOM描述与浏览器进行交互的方法和接口。</p>
<h3 id="3-JavaScript-中的事件处理是如何进行的？"><a href="#3-JavaScript-中的事件处理是如何进行的？" class="headerlink" title="3.JavaScript 中的事件处理是如何进行的？"></a>3.JavaScript 中的事件处理是如何进行的？</h3><p>如下图所示，我们有三个 div 元素。它们每个都有一个与之关联的单击处理程序。处理程序执行以下任务：外部 div 处理程序将 hello outer 打印到控制台。<br>内部 div 处理程序将 hello inner 打印到控制台。最内部的 div 处理程序将 hello innermost 打印到控制台。<br>编写一段代码来分配这些处理程序，以便在单击最里面的 div 时始终打印以下序列。hello inner → hello innermost → hello outer</p>
<p>答：思路就是使用事件冒泡和事件捕获<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="string">"outer"</span>).addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(e)&#123;</span><br><span class="line">		alert(<span class="string">'hello outer'</span>);</span><br><span class="line">&#125;);//也可以不写这个参数，默认是<span class="literal">false</span></span><br><span class="line">document.getElementById(<span class="string">"inner"</span>).addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(e)&#123;</span><br><span class="line">	alert(<span class="string">'hello inner'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line">document.getElementById(<span class="string">"innermost"</span>).addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(e)&#123;</span><br><span class="line">	alert(<span class="string">'hello innermost'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于这种代码，判断弹出顺序时，可以这样判断：<br>首先，假设所有的都是false，那么正常顺序是innermost→inner→outer，然后由最里层往外层的div一个一个去看，如果碰到一个div是true,那么就把它的位置放在当前顺序的最头部即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/27/前端面试题记录/" data-id="cjqm2qopx0009xcte2ut3nhnf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-水平垂直居中div" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/水平垂直居中div/" class="article-date">
  <time datetime="2018-11-26T07:23:15.629Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/水平垂直居中div/">水平垂直居中div</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将id=”container”的div水平垂直居中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span>&gt;</span><br><span class="line">我的div要水平垂直居中</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	margin: 0;</span><br><span class="line">	padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>水平居中当然都知道，需要margin: 0 auto;即可，但是如何水平垂直居中呢？<br>position:relative 配合top:50%无效，但是left：50%有效。<br>是因为子元素设置的width或者height是百分比的值跟父元素有关。设置width为百分比，不需要父元素明确设置width；但是子元素设置height为百分比，父元素必须明确设置高度。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>使用绝对布局，让left为50%，这样水平方向上div的最左与屏幕的最左相距50%，所以还需将div再向左移动半个宽度，所以margin-left: -100px;，或者通过transform: translate(-50%,-50%);设置。top方向上同理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#container&#123;</span></span><br><span class="line">	text-align: center;</span><br><span class="line">    background: pink;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    /*transform: translate(-50%,-50%);*/</span><br><span class="line">    margin-top: -100px;</span><br><span class="line">    margin-left: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查元素可以发现：<br>position: absolute时，body元素的高为0,表示body元素的高为整个页面的高度；<br>position: relative时，body元素的高为200px。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用绝对布局，一定要设置margin:auto,并设置top,right,bottom,right值相等即可，不一定要都是0。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#container&#123;</span></span><br><span class="line">    background: pink;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0px;</span><br><span class="line">    left: 0px;</span><br><span class="line">    right: 0px;</span><br><span class="line">    bottom: 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二的原理如下："><a href="#方法二的原理如下：" class="headerlink" title="方法二的原理如下："></a>方法二的原理如下：</h3><p>首先说一下margin的auto属性的作用：它是用来分配剩余空间的，所以说一定对有剩余空间的元素才有效。例如对图片元素这个属性无效，是因为图片是内联元素，不是占一整行的，所以说它没有剩余空间。<br>1.position: absolute;使绝对定位块跳出了内容流。<br>定位元素可以发现，当该属性为absolute时，body元素的高为整个页面的高度；当属性为relative时，body元素的高就刚好只是该元素width值的高度；<br>2.为块级区域设置top: 0; left: 0; bottom: 0; right: 0;将给浏览器重新分配一个边界框，此时该块将填充其所有父元素的所有可用空间，所以margin在垂直方向上有了可分配的空间。<br>3.再设置margin垂直方向上下为auto，即可实现垂直居中。</p>
<h2 id="对position的absolute和relative属性不清楚，通过链接了解了一些：https-www-cnblogs-com-theWayToAce-p-5264436-html"><a href="#对position的absolute和relative属性不清楚，通过链接了解了一些：https-www-cnblogs-com-theWayToAce-p-5264436-html" class="headerlink" title="对position的absolute和relative属性不清楚，通过链接了解了一些：https://www.cnblogs.com/theWayToAce/p/5264436.html"></a>对position的absolute和relative属性不清楚，通过链接了解了一些：<a href="https://www.cnblogs.com/theWayToAce/p/5264436.html" target="_blank" rel="noopener">https://www.cnblogs.com/theWayToAce/p/5264436.html</a></h2><p>现自己再总结一下如下：<br>1.relative<br><em>生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。</em><br>定位为relative的元素脱离正常文本流中，但其在文本流中的位置依然存在。<br>无论父级存在不存在，无论有没有TRBL（ “left”, “top”, “right” 以及 “bottom” ），均是以父级的左上角进行定位，但是父级的padding属性会对其影响。</p>
<p>2.absolute<br><em>生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</em><br>定位为absolute的元素脱离正常文本流，但是其在正常流中的位置不再存在。<br>若想把一个定位属性为absolute的元素定位于其父级元素内，只有满足两个条件：设定TRBL和父级设定position属性(无论是absolute还是relative)。这两个条件只要有一个不满足，元素就会以浏览器左上角为原点，从而导致页面布局错位。<br>如果有父级元素，则定位属性为absolute的元素是以父级为左上角；如果没有父级，才会参照浏览器的左上角。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/26/水平垂直居中div/" data-id="cjqm2qoq1000cxcte8p9au5nf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/React生命周期/" class="article-date">
  <time datetime="2018-11-26T02:42:46.435Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/React生命周期/">React生命周期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React生命周期分为三种状态，分别是mounting,updating,unmounting;意味着已插入真实的DOM，正在被重新渲染，已从真实的DOM移除。<br>因此，对应的生命周期方法有：<br>componentWillMount ，componentDidMount ，<br>componentWillReceiveProps ，shouldComponentUpdate ，<br>componentWillUpdate，componentDidUpdate ，<br>componentWillUnmount。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class TestComp extends React.Component &#123;</span><br><span class="line">	<span class="function"><span class="title">componentWillMount</span></span>() &#123;</span><br><span class="line">		console.log(<span class="string">"componentWillMount"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">		//可以在该方法中调用setTimeout，setInterval等操作。</span><br><span class="line">		console.log(<span class="string">"componentDidMount"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	componentWillReceiveProps(newProps) &#123;</span><br><span class="line">		console.log(<span class="string">"componentWillReceiveProps"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	shouldComponentUpdate(newProps, newState) &#123;</span><br><span class="line">		console.log(<span class="string">"shouldComponentUpdate"</span>);</span><br><span class="line">		//如果为<span class="literal">false</span>，不会执行后面的生命周期方法</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	componentWillUpdate(newProps, newState) &#123;</span><br><span class="line">		console.log(<span class="string">"componentWillUpdate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	componentDidUpdate(newProps, newState) &#123;</span><br><span class="line">		console.log(<span class="string">"componentDidUpdate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">		console.log(<span class="string">"componentWillUnmount"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;h3&gt;&#123;this.props.number&#125;&lt;/h3&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IncreButton extends React.Component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state =  &#123;number: 0&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	setNewNumber = () =&gt; &#123;</span><br><span class="line">		this.setState(&#123;number: this.state.number +1&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;button onClick = &#123;this.setNewNumber&#125;&gt;加1&lt;/button&gt;</span><br><span class="line">				&lt;TestComp number = &#123;this.state.number&#125;&gt;&lt;/TestComp&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;IncreButton /&gt;</span><br><span class="line">	&lt;/div&gt;,</span><br><span class="line">	document.getElementById(<span class="string">"example"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注:<br>1.页面一加载，componentWillMount，componentDidMount<br>2.每次点击加1按钮后，componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，componentDidUpdate</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/26/React生命周期/" data-id="cjqm2qopv0008xcteqjdidiod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-圣杯布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/圣杯布局/" class="article-date">
  <time datetime="2018-11-22T07:30:14.233Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/圣杯布局/">圣杯布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>圣杯布局就是把页面分成了三列，左右两列的内容是固定宽度的，中间列的内容是自适应宽度的。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.清除整个页面的内外边距。<br>2.写html代码，三个div分别对应左中右三列，先写middle,其次是left和right。<br>3.将middle列的宽度设置成100%，这样就可以做到其宽度自适应。三个div都设置成内联块，然后向左浮动。<br>4.此时left因为被挤到了第二行，所以将其左移middle宽度的位置，所以margin-left: -100%;<br>5.然而此时middle最左端的部分被left盖住了，所以要把middle拉出来，设置container左边的内边距为200px;<br>6.此时left也同时被向右拉了，所以left应该相对于它本身的位置，再向左移动200px,因此设置middle为position: relative;left: -200px;<br>注：<br>position: relative;位置被设置为relative的元素，可将其移至相对于其正常位置的地方。因为left: -200px;会将元素移至元素正常位置左边200个像素的位置。<br>7.right的布局调整类似于left。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	margin: 0;</span><br><span class="line">	padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#container&#123;</span></span><br><span class="line">	padding: 0 250px 0 200px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#middle, #left, #right&#123;</span></span><br><span class="line">	<span class="built_in">float</span>: left;</span><br><span class="line">	position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#middle&#123;</span></span><br><span class="line">	width: 100%;</span><br><span class="line">	background: yellow;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left&#123;</span></span><br><span class="line">	width: 200px;</span><br><span class="line">	margin-left: -100%;</span><br><span class="line">	left: -200px;</span><br><span class="line">	background: green;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#right&#123;</span></span><br><span class="line">	width: 250px;</span><br><span class="line">	margin-left: -250px;</span><br><span class="line">	right: -250px;</span><br><span class="line">	background: pink;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"container"</span>&gt;</span><br><span class="line">	&lt;div id=<span class="string">"middle"</span>&gt;</span><br><span class="line">		middlemiddlemiddlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">		hereherehereherehereherehereherehereherehere</span><br><span class="line">		middlemiddlemiddlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">		hereherehereherehereherehereherehereherehere</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div id=<span class="string">"left"</span>&gt;</span><br><span class="line">		leftleftleftleftleftleftleftleftleftleft</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div id=<span class="string">"right"</span>&gt;</span><br><span class="line">		rightrightrightrightrightrightright</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/圣杯布局/" data-id="cjqm2qoqd000fxctevwko4vup" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/07/promise/">promise</a>
          </li>
        
          <li>
            <a href="/2019/01/05/macrotask microtask/">macrotask microtask</a>
          </li>
        
          <li>
            <a href="/2018/12/19/this学习/">this学习</a>
          </li>
        
          <li>
            <a href="/2018/12/18/闭包和立即执行函数/">闭包和立即执行函数</a>
          </li>
        
          <li>
            <a href="/2018/12/05/异步，同步，回调和class/">异步，同步，回调和js的class</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>