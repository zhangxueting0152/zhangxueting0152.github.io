<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-BFC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/BFC/" class="article-date">
  <time datetime="2019-03-26T12:13:18.000Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/BFC/">BFC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><h3 id="Formatting-context"><a href="#Formatting-context" class="headerlink" title="Formatting context"></a>Formatting context</h3><p>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>“块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><p>内部的Box会在垂直方向，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。<br>生成BFC元素的子元素中，每一个子元素的外边距会与包含块的左边界相接触，即使存在浮动也是如此。除非这个子元素也创建了一个新的BFC。<br>BFC的区域不会与float box重叠。<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算BFC的高度时，浮动元素也参与计算。</p>
<h3 id="BFC如何产生"><a href="#BFC如何产生" class="headerlink" title="BFC如何产生"></a>BFC如何产生</h3><p>根元素<br>float属性不为none<br>position为absolute或fixed，即为绝对定位元素<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>overflow不为visible</p>
<h2 id="BFC作用"><a href="#BFC作用" class="headerlink" title="BFC作用"></a>BFC作用</h2><h3 id="1-清除内部浮动（当浮动元素无法撑起父元素时）"><a href="#1-清除内部浮动（当浮动元素无法撑起父元素时）" class="headerlink" title="1.清除内部浮动（当浮动元素无法撑起父元素时）"></a>1.清除内部浮动（当浮动元素无法撑起父元素时）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line"><span class="comment">#father &#123;</span></span><br><span class="line">	width: 300px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	border: 2px blue solid;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 300px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">	<span class="built_in">float</span>: left;</span><br><span class="line">	border: 2px red solid;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=<span class="string">"father"</span>&gt;</span><br><span class="line">		&lt;div class=<span class="string">"child"</span>&gt;child1&lt;/div&gt;</span><br><span class="line">		&lt;div class=<span class="string">"child"</span>&gt;child2&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/1_1.png" alt="1_1"><br>修改原理：计算BFC的高度时，浮动元素也参与计算。所以为了达到清除内部浮动的目的，可以让father div生成一个BFC。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#father &#123;</span></span><br><span class="line">	width: 300px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	border: 2px blue solid;</span><br><span class="line">	overflow: hidden; // father变成BFC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/1_2.png" alt="1_2"></p>
<h3 id="2-解决垂直margin重叠"><a href="#2-解决垂直margin重叠" class="headerlink" title="2.解决垂直margin重叠"></a>2.解决垂直margin重叠</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">p &#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	margin: 50px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;box2&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/2_1.png" alt="2_1"><br>可以看到，box1和box2的距离是100px，不是我们预期的200px。发生了maigin重叠。<br>修改原理：box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box会发生margin重叠。那么我们可以在box2外面包裹一层容器，并出发该容器生成一个BFC。那么两个div就不属于同于一个BFC了，也就不会margin重叠了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">p &#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	margin: 50px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#bfc &#123;</span></span><br><span class="line">	overflow: hidden; // **</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">	&lt;div id=<span class="string">"bfc"</span>&gt; // **</span><br><span class="line">		&lt;p&gt;box2&lt;/p&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/2_2.png" alt="2_2"><br>注意，直接给box2加bfc不起作用，必须给box2外面包裹一层。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;box1&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"bfc"</span>&gt;box2&lt;/p&gt; // 错误</span><br></pre></td></tr></table></figure></p>
<h3 id="3-自适应两栏布局（解决不被浮动元素覆盖问题）"><a href="#3-自适应两栏布局（解决不被浮动元素覆盖问题）" class="headerlink" title="3.自适应两栏布局（解决不被浮动元素覆盖问题）"></a>3.自适应两栏布局（解决不被浮动元素覆盖问题）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">.aside &#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 100px;</span><br><span class="line">	background-color: gray;</span><br><span class="line">	<span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">	height:  120px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=<span class="string">"aside"</span>&gt;aside&lt;/div&gt;</span><br><span class="line">	&lt;div class=<span class="string">"main"</span>&gt;main&lt;/div&gt;	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/26/BFC/3_1.png" alt="3_1"><br>修改原理：每个元素的margin box的左边， 与包含块border box的左边相接触。因此，虽然存在浮动的元素aside，但main的左边依然会与包含块的左边相接触。但是BFC的区域不会与float box重叠。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">	height:  120px;</span><br><span class="line">	background-color: pink;</span><br><span class="line">	overflow: hidden; // **</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/26/BFC/3_2.png" alt="3_2"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/BFC/" data-id="cjtprk6vf0000v4tewmj7qo63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-位运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/17/位运算符/" class="article-date">
  <time datetime="2019-03-17T09:41:46.615Z" itemprop="datePublished">2019-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/17/位运算符/">位运算符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>位运算符是在数字底层（即表示数字的 32 个数位）进行操作的。<br>有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。<br>负数也存储为二进制代码，不过采用的形式是二进制补码。计算数字二进制补码的步骤有三步：</p>
<pre><code>确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）
求得二进制反码，即要把 0 替换为 1，把 1 替换为 0
在二进制反码上加 1
</code></pre><p>例如：要确定 -18 的二进制表示：<br>18 的二进制表示：0000 0000 0000 0000 0000 0000 0001 0010<br>计算二进制反码 ：1111 1111 1111 1111 1111 1111 1110 1101<br>二进制反码加 1： 1111 1111 1111 1111 1111 1111 1110 1110（-18的二进制表示）</p>
<h2 id="位运算NOT"><a href="#位运算NOT" class="headerlink" title="位运算NOT ~"></a>位运算NOT ~</h2><p>位运算 NOT 由否定号（ ~ ）表示<br>位运算 NOT 是三步的处理过程：<br>    把运算数转换成 32 位数字<br>    把二进制数转换成它的二进制反码<br>    把二进制数转换成浮点数<br>例如：<br>var iNum1 = 25;        //25 等于 00000000000000000000000000011001<br>var iNum2 =  ~ iNum1;    //转换为 11111111111111111111111111100110<br>alert(iNum2);        //输出 “-26”</p>
<p>位运算 NOT 实质上是对数字求负，然后减 1，因此 25 变 -26。</p>
<h2 id="位运算-AND-amp"><a href="#位运算-AND-amp" class="headerlink" title="位运算 AND &amp;"></a>位运算 AND &amp;</h2><p>位运算 AND 由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后按位计算。只有1 1才得到1.</p>
<h2 id="位运算-OR"><a href="#位运算-OR" class="headerlink" title="位运算 OR |"></a>位运算 OR |</h2><p>位运算 OR 由和号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，只有0 0 才得到0.</p>
<h2 id="位运算-XOR"><a href="#位运算-XOR" class="headerlink" title="位运算 XOR ^"></a>位运算 XOR ^</h2><p>位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。即两位不同才是1.</p>
<h2 id="左移运算"><a href="#左移运算" class="headerlink" title="左移运算"></a>左移运算</h2><p>左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）。<br>左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。</p>
<h2 id="有符号右移运算"><a href="#有符号右移运算" class="headerlink" title="有符号右移运算"></a>有符号右移运算</h2><p>有符号右移运算符由两个大于号表示（&gt;&gt;）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。<br>同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字。</p>
<h2 id="无符号右移运算"><a href="#无符号右移运算" class="headerlink" title="无符号右移运算"></a>无符号右移运算</h2><p>无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。<br>对于负数，情况就不同了。<br>无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/17/位运算符/" data-id="cjtprk6w2000ev4tecrxcgpb3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数组遍历方法汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/24/数组遍历方法汇总/" class="article-date">
  <time datetime="2019-02-24T12:29:04.678Z" itemprop="datePublished">2019-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/24/数组遍历方法汇总/">数组遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach是数组的内置方法，但是无法中途跳出循环。遍历数组中的每一项，没有返回值，对原数组没有影响。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach((item,index,array)=&gt;&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>for in遍历的是数组的键名，会遍历手动添加的其他键，甚至包括原型链上的键。它是以字符串作为键名，为遍历对象而设计的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	console.log(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of ***"></a>for…of ***</h2><p>可以与break、continue和return配合使用，它提供了遍历所有数据结构的统一操作接口。它遍历的是键值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="keys，values，entries"><a href="#keys，values，entries" class="headerlink" title="keys，values，entries"></a>keys，values，entries</h2><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of arr.keys()) &#123;</span><br><span class="line">	console.log(key);</span><br><span class="line">&#125; // 0 1 2 </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr.values()) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125; // 1 4 3</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of arr.entries()) &#123;</span><br><span class="line">	console.log([key, value]);</span><br><span class="line">&#125; // [0, 1] [1, 4] [2, 3]</span><br></pre></td></tr></table></figure></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的回调函数中支持return返回值,不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="keyword">function</span>(value,index,array)&#123;</span><br><span class="line">　　//<span class="keyword">do</span> something</span><br><span class="line">　　<span class="built_in">return</span> XXX </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.map((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// [10,40,30]</span><br><span class="line">console.log(arr);// [1,4,3]</span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>不会改变原始数组,返回新数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.filter((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// [4, 3]</span><br><span class="line">console.log(arr);// [1,4,3]</span><br></pre></td></tr></table></figure></p>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.every((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>如果该函数对任一项返回true，则返回true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.some((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce((previousValue, currentValue, index, array) =&gt; &#123;</span><br><span class="line"> <span class="built_in">return</span> previousValue + currentValue;// 根据需要修改</span><br><span class="line">&#125;， initialValue);</span><br></pre></td></tr></table></figure></p>
<p>initialValue参数可选，表示归并基础的初始值。</p>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p>reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>返回数组中符合测试函数条件的第一个元素。否则返回undefined 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,4,3]; </span><br><span class="line">var res = arr.find((item,index,arr) =&gt; &#123; </span><br><span class="line">    <span class="built_in">return</span> item &gt; 2; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);// 4</span><br></pre></td></tr></table></figure></p>
<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p>对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].findIndex(<span class="keyword">function</span>(x) &#123; x == 2; &#125;);</span><br><span class="line">// Returns an index value of 1.</span><br></pre></td></tr></table></figure></p>
<p>并不是所有类似数组的结构都具有Iterator接口，但可以使用Array.from方法将其转为数组；<br>for…of遍历内部调用的是数据结构中的Symbol.iterator方法。</p>
<h2 id="数组的去重方法"><a href="#数组的去重方法" class="headerlink" title="数组的去重方法"></a>数组的去重方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const removeDuplicateItems = arr =&gt; &#123;<span class="built_in">return</span> [...new Set(arr)];&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [1,3,5,2,5,1];</span><br><span class="line"><span class="built_in">let</span> newArr = removeDuplicateItems(arr);</span><br><span class="line">console.log(arr);// [1, 3, 5, 2, 5, 1]</span><br><span class="line">console.log(newArr);// [1, 3, 5, 2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> uniq(array) &#123;</span><br><span class="line">    <span class="built_in">let</span> tmpArr = [];</span><br><span class="line">    array.forEach((value, index, array) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpArr.indexOf(value) == -1) &#123;</span><br><span class="line">            tmpArr.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> tmpArr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniq(arr));// [1, 3, 5, 2]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/24/数组遍历方法汇总/" data-id="cjtprk6w7000iv4te3p3x9k13" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-防抖和节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/22/防抖和节流/" class="article-date">
  <time datetime="2019-02-22T02:46:41.953Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/22/防抖和节流/">防抖和节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>附上学习连接<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5</a></p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间;<br>每次触发事件时都取消之前的延时调用方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">'inp'</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn) &#123;</span><br><span class="line">	<span class="built_in">let</span> timeout = null;// 创建一个标记用来存放定时器的返回值</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		clearTimeout(timeout);// 每当用户输入的时候把前一个setTimeout clear掉</span><br><span class="line">		timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">			fn.apply(this, arguments);</span><br><span class="line">		&#125;, 500);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayHi</span></span>() &#123;</span><br><span class="line">	console.log(<span class="string">'防抖成功'</span>);</span><br><span class="line">&#125;</span><br><span class="line">var inp = document.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi));</span><br></pre></td></tr></table></figure></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率;<br>每次触发事件时都判断当前是否有等待执行的延时函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throttle(fn) &#123;</span><br><span class="line">	<span class="built_in">let</span> canRun = <span class="literal">true</span>;// 通过闭包保存一个标记</span><br><span class="line">	<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (!canRun) <span class="built_in">return</span>;</span><br><span class="line">		canRun = <span class="literal">false</span>; // 立即设置为<span class="literal">false</span></span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			fn.apply(this, arguments);</span><br><span class="line">			canRun = <span class="literal">true</span>;</span><br><span class="line">		&#125;, 500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> sayHi(e) &#123;</span><br><span class="line">	console.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, throttle(sayHi));</span><br></pre></td></tr></table></figure></p>
<p>函数节流和函数去抖的核心其实就是限制某一个方法被频繁触发，而一个方法之所以会被频繁触发，大多数情况下是因为 DOM 事件的监听回调，而这也是函数节流以及防抖多数情况下的应用场景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/22/防抖和节流/" data-id="cjtprk6wd000pv4te6g4s5d43" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-渲染机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/11/渲染机制/" class="article-date">
  <time datetime="2019-01-11T03:02:23.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/11/渲染机制/">渲染机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器的渲染过程："><a href="#浏览器的渲染过程：" class="headerlink" title="浏览器的渲染过程："></a>浏览器的渲染过程：</h2><p><img src="/2019/01/11/渲染机制/浏览器渲染过程.png" alt="浏览器渲染过程"></p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>
</ol>
<h2 id="Load-和-DOMContentLoaded："><a href="#Load-和-DOMContentLoaded：" class="headerlink" title="Load 和 DOMContentLoaded："></a>Load 和 DOMContentLoaded：</h2><p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。<br>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待CSS，JS，图片加载。</p>
<h2 id="图层："><a href="#图层：" class="headerlink" title="图层："></a>图层：</h2><p>可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。<br>不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。<br>生成新图层的属性：</p>
<ol>
<li>3D 变换：translate3d、translateZ</li>
<li>will-change<br>例如想通知浏览器会发生一个transform方面的变化，可以这样写：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">	will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐的做法是当一个元素或属性发生变化时打开will-change，变化完成之后关闭它。</p>
<ol start="3">
<li>video、iframe 标签</li>
<li>通过动画实现的 opacity 动画转换</li>
<li>position: fixed</li>
</ol>
<h2 id="重绘（Repaint）和回流（Reflow）："><a href="#重绘（Repaint）和回流（Reflow）：" class="headerlink" title="重绘（Repaint）和回流（Reflow）："></a>重绘（Repaint）和回流（Reflow）：</h2><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘。<br>回流是布局或者几何属性需要改变就称为回流。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的。<br>例如，改变 window 大小，改变字体，添加或删除样式，定位或者浮动都会导致性能问题。</p>
<p>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。<br>会依次判断是否有 resize 或者 scroll，是否触发了 media query，更新动画，全屏操作事件，执行 requestAnimationFrame，执行 IntersectionObserver等等，然后更新界面。</p>
<p>减少重绘和回流的方法：</p>
<ol>
<li><p>使用 translate 替代 top</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-$(<span class="string">'.x'</span>).css(<span class="string">'top'</span>, <span class="string">'200px'</span>)</span><br><span class="line">+$(<span class="string">'.x'</span>).css(<span class="string">'translateY'</span>, <span class="string">'translateY(200px)'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）。</p>
</li>
<li>把 DOM 离线后（例如将DOM设置为display:none）再修改，改完后再将其显示出来。</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。</li>
<li>不要使用table，因为可能很小的一个小改动会造成整个 table 的重新布局。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/11/渲染机制/" data-id="cjtprk6wc000nv4te58asxktp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/10/存储/" class="article-date">
  <time datetime="2019-01-10T10:34:46.906Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/存储/">存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cookie，localStorage，sessionStorage，indexDB<br>Web Storage（Local Storage和Session Storage）使用简单字符串键值对在本地存储数据，方便灵活，但是不适于大量结构化数据存储。<br>indexDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。<br>对于简单的数据，应该使用localstorage，但当存储大量数据时，indexDB会更适合，indexDB能提供更为复杂的查询数据的方式。</p>
<p>浏览器端：<br>cookie<br>WebStorage(localStorage、sessionStorage)<br>userData：IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>indexedDB<br>服务器端：<br>session</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie由服务器生成，可以设置过期时间；第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。<br>数据存储大小是4k；<br>参与与服务端通信时，每次都会携带在header中，对于请求性能影响。<br>不建议用于存储。<br>对于cookie,需要注意安全问题：<br>1.value属性用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识；<br>2.http-only属性：若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。<br>从而减少XSS攻击。<br>3.secure属性：设置是否只能通过https来传递此条cookie；<br>4.same-site：规定浏览器不能在跨域请求中携带cookie，减少CSRF攻击。</p>
<p>适用场景：存储用户的登录信息</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage除非被清理，否则一直存在；<br>数据存储大小是5M；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">https://www.cnblogs.com/st-leslie/p/5617130.html</a><br>localStorage主要是用来作为本地存储来使用的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.优点：<br>localStorage拓展了cookie的4K限制，解决了cookie存储空间不足的问题，localStorage中一般浏览器支持的是5M大小。<br>localStorage可以将第一次请求的数据直接存储到本地。<br>2.局限：<br>localStorage的值类型限定为string类型，所以对我们JSON对象类型需要一些转换。<br>localStorage在浏览器的隐私模式下面是不可读取的。<br>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。<br>localStorage不能被爬虫抓取到。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>setItem(),getItem(),clear(),removeItem(),storage.keyName = value<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!window.localStorage)&#123;</span><br><span class="line">    alert(<span class="string">"浏览器不支持localstorage"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    var storage = window.localStorage;</span><br><span class="line">    var data = &#123;</span><br><span class="line">    	name: <span class="string">'zxt'</span>,</span><br><span class="line">    	age: 23,</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"a"</span>,4);</span><br><span class="line">    storage.setItem(<span class="string">"b"</span>,5);</span><br><span class="line">    storage.setItem(<span class="string">"data"</span>,JSON.stringify(data));</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 4</span><br><span class="line">    storage.a = 7;// 修改值</span><br><span class="line">    console.log(storage.getItem(<span class="string">"a"</span>));// 7</span><br><span class="line">    storage.removeItem(<span class="string">"a"</span>);</span><br><span class="line">    // storage.clear();// 清除storage的所有内容</span><br><span class="line">    console.log(storage.key(0));// b 输入索引即可获取对应的键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用场景：<br>当用户欠费时，希望每个月给用户弹出一次提示框，用于提醒用户“已欠费”,那么用localStorage;<br>当用户欠费时，希望用户每次打开指定页面时弹出一次提示框，用于提醒用户“已欠费”,sessionStorage.</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage页面关闭就被清理；<br>数据存储大小是5M；<br>不参与与服务端通信。</p>
<p>localStorage与sessionStorage的区别是localStorage属于永久性存储，而sessionStorage属于当会话结束(例如页面关闭)的时候，sessionStorage中的键值对会被清空.</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>indexDB除非被清理，否则一直存在；<br>数据存储大小是无限的；<br>不参与与服务端通信。<br><a href="https://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphinX/p/3415761.html</a><br>indexedDB是一个非关系型数据库系统,然而它是使用JavaScript对象,而不是列数固定的表格来存储数据的。<br>indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。</p>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>本质上充当应用程序和浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。旨在使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。<br>待学习~<br>站渐进式增强体验(PWA)改造：Service Worker 应用<br>Service Worker 最主要的特点是：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</p>
<p>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。<br><a href="http://lzw.me/a/pwa-service-worker.html" target="_blank" rel="noopener">http://lzw.me/a/pwa-service-worker.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/存储/" data-id="cjtprk6w6000hv4te1i59ve6q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-跨域请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/跨域请求/" class="article-date">
  <time datetime="2019-01-09T02:53:35.680Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/跨域请求/">js跨域请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p>同源：是指协议，域名和端口相同。<br>同源策略：基于安全考虑，当前域不能访问其他域的东西。<br>如果a的URL是<a href="http://www.a.com:8080/test1/a.js" target="_blank" rel="noopener">http://www.a.com:8080/test1/a.js</a> ，那么<br>1.b的url是<a href="https://www.a.com:8080/test1/a.js" target="_blank" rel="noopener">https://www.a.com:8080/test1/a.js</a> 时，a和b不同源，因为协议不同；<br>2.b的url是<a href="http://www.b.com:8080/test1/a.js" target="_blank" rel="noopener">http://www.b.com:8080/test1/a.js</a> 时，a和b不同源，因为域名不同；<br>3.b的url是<a href="http://www.a.com:3000/test1/a.js" target="_blank" rel="noopener">http://www.a.com:3000/test1/a.js</a> 时，a和b不同源，因为端口不同；<br>4.b的url是<a href="http://www.a.com:8080/test2/a.js" target="_blank" rel="noopener">http://www.a.com:8080/test2/a.js</a> 时，a和b同源，是同一域名下的不同文件夹；<br>5.<a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 和<a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a> 是同源的，在同一域名下。</p>
<h2 id="跨域请求方式"><a href="#跨域请求方式" class="headerlink" title="跨域请求方式"></a>跨域请求方式</h2><p>记住JSONP,CORS,document.doamin,postMessage</p>
<h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>原理就是动态创建script标签，然后利用script标签没有跨域限制的漏洞。<br>JSONP使用简单，但是只限于get请求。<br>原理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">function</span> jsonp(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>开发中，可以这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mydiv"</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		var myBtn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">		myBtn.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">			var script = document.createElement(<span class="string">"script"</span>);</span><br><span class="line">			script.src = <span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>;</span><br><span class="line">			script.type = <span class="string">"text/javascript"</span>;  </span><br><span class="line">			document.body.insertBefore(script, document.body.firstChild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> callback(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-document-domain-iframe"><a href="#2-document-domain-iframe" class="headerlink" title="2.document.domain + iframe"></a>2.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。<br>只需要给页面添加document.domain=”test.com”表示二级域名都相同就可以实现跨域。<br>我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。<br>页面<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"http://example.com/b.html"</span> id=<span class="string">"iframe"</span> onload=<span class="string">"test()"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain = <span class="string">'example.com'</span>;// 设置成主域</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">	alert(document.getElementById(<span class="string">'iframe'</span>).contentWindow);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.domain = <span class="string">'example.com'</span>;// 使得这个页面于主页面的document.domain相同</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过js访问到iframe中的各种属性和对象了。</p>
<h3 id="3-window-name-iframe"><a href="#3-window-name-iframe" class="headerlink" title="3.window.name + iframe"></a>3.window.name + iframe</h3><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>原理就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。<br>页面<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"http://www.source.com/data.html"</span> id=<span class="string">"proxy"</span> onload=<span class="string">"getData()"</span> style=<span class="string">"display: none"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// iframe载入data.html页面后会执行此函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">	var iframe= document.getElementById(<span class="string">'proxy'</span>);</span><br><span class="line">	iframe.src = <span class="string">'b.html'</span>;// 这里的b.html是任意一个页面，只要和a.html同源即可，便可以保证a.html访问到iframe里的东西。设置成‘’也可以。</span><br><span class="line">	iframe.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">		var data = iframe.contentWindow.name;// 获取iframe里的window.name，里面存放着设置的数据。</span><br><span class="line">		alert(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://www.source.com/data.html" target="_blank" rel="noopener">http://www.source.com/data.html</a> 的写法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.name = <span class="string">'要传给页面a.html的数据，所有可以转化成字符串的数据都可以放在这里'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-HTML5中window-postMessage方法"><a href="#4-HTML5中window-postMessage方法" class="headerlink" title="4.HTML5中window.postMessage方法"></a>4.HTML5中window.postMessage方法</h3><p>调用postMessage方法的window对象是指要发送消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</p>
<p>页面<a href="http://localhost/parent.html" target="_blank" rel="noopener">http://localhost/parent.html</a> 的写法:接收消息(端口不写时默认是80端口)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;父窗口&lt;/div&gt;</span><br><span class="line">	&lt;iframe src=<span class="string">"http://localhost:92/child.html"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">	console.log(event.data);// 我是子窗口</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>页面<a href="http://localhost:92/child.html" target="_blank" rel="noopener">http://localhost:92/child.html</a> 的写法:发送消息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;子窗口&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	window.parent.postMessage(<span class="string">"我是子窗口"</span>, <span class="string">'http://localhost:80/parent.html'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-web-sockets"><a href="#5-web-sockets" class="headerlink" title="5.web sockets"></a>5.web sockets</h3><p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。<br>同源策略对web sockets不适用。<br>原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。<br>只有在支持web socket协议的服务器上才能正常工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var socket= new WebSocket(<span class="string">'ws://www.baidu.com'</span>);// http-&gt;ws; https-&gt;wss</span><br><span class="line">socket.send(<span class="string">"hello WebSocket"</span>);</span><br><span class="line">socket.onMessage = <span class="keyword">function</span>(event) &#123;</span><br><span class="line">	var data = event.data;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6-CORS"><a href="#6-CORS" class="headerlink" title="6.CORS"></a>6.CORS</h3><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>是 JSONP 模式的现代版。CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。<br>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compatibleCORS(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    <span class="keyword">if</span> (xhr.withCredentials !== undefined) &#123;</span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeof XDomainRequest !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        //XDomainRequest是IE用于支持CORS请求的对象</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> xhr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var xhr = compatibleCORS(<span class="string">'GET'</span>, <span class="string">"your url"</span>);</span><br><span class="line"><span class="keyword">if</span> (!xhr) &#123;</span><br><span class="line">    throw new Erorr(<span class="string">"CORS不被支持"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端:<br>通过设置http响应头Access-Control-Allow-Origin: <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> (这里可以是* , 代表接所有网站都可以访问资源)。</p>
<p>下面这段代码还不理解是干嘛的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    // 头信息配置</span><br><span class="line">&#125;).<span class="keyword">then</span>(() =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-location-hash-iframe"><a href="#7-location-hash-iframe" class="headerlink" title="7.location.hash + iframe"></a>7.location.hash + iframe</h3><p>利用 location.hash 来传值。 缺点：数据直接暴露在url中，大小、类型都有限制。<br>例1：<br>原理是利用location.hash来进行传值。<br>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。<br>1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面<br>2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据<br>3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值<br>注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe<br>a.com下的文件cs1.html文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">startRequest</span></span>()&#123;</span><br><span class="line">    var ifr = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifr.src = <span class="string">'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'</span>;</span><br><span class="line">    document.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">checkHash</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var data = location.hash ? location.hash.substring(1) : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (console.log) &#123;</span><br><span class="line">            console.log(<span class="string">'Now the data is '</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, 2000);</span><br></pre></td></tr></table></figure></p>
<p>cnblogs.com域名下的cs2.html:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//模拟一个简单的参数处理操作</span><br><span class="line">switch(location.hash)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramdo'</span>:</span><br><span class="line">        callBack();</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramset'</span>:</span><br><span class="line">        //<span class="keyword">do</span> something……</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">callBack</span></span>()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        parent.location.hash = <span class="string">'somedata'</span>;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        // ie、chrome的安全机制无法修改parent.location.hash，</span><br><span class="line">        // 所以要利用一个中间的cnblogs域下的代理iframe</span><br><span class="line">        var ifrproxy = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        ifrproxy.style.display = <span class="string">'none'</span>;</span><br><span class="line">        ifrproxy.src = <span class="string">'http://a.com/test/cscript/cs3.html#somedata'</span>;    // 注意该文件在<span class="string">"a.com"</span>域下</span><br><span class="line">        document.body.appendChild(ifrproxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>a.com下的域名cs3.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(1);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/2050/p/3191744.html" target="_blank" rel="noopener">https://www.cnblogs.com/2050/p/3191744.html</a><br><a href="https://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="noopener">https://blog.csdn.net/joyhen/article/details/21631833</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/跨域请求/" data-id="cjtprk6wj000rv4tes960whom" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-post和get" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/post和get/" class="article-date">
  <time datetime="2019-01-09T01:37:41.275Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/post和get/">post和get区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.数据量：<br>post对请求参数的长度没有限制，而get如果请求参数过长，会被浏览器截断。<br>GET：不同的浏览器和服务器不同，一般限制在2~8K之间，更加常见的是1k以内<br>POST方法提交的数据比较大，大小靠服务器的设定值限制。<br>2.安全性：<br>get比post更不安全，get请求参数会直接暴露在URL上，所以不适合用来传递敏感信息。post放在request body中。<br>get请求只能进行url编码，而post支持多种编码方式。<br>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br>get请求在浏览器回退时是无害的，而post会再次提交请求。<br>3.缓存：<br>get请求产生的URL可以被浏览器主动缓存，而post请求不可以，除非手动设置。<br>4.效率：<br>get的意思是”得”，从服务器获取数据（也可以上传数据，参数就是），效率较高；<br>post的意思是“给”，但可以向服务器发送数据和下载数据，效率不如get；<br>get和post本质上就是TCP链接.get产生一个tcp数据包，post产生两个TCP数据包。<br>对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/post和get/" data-id="cjtprk6vw0009v4te64dxtexw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-generator和async函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/generator和async函数/" class="article-date">
  <time datetime="2019-01-08T02:23:48.429Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/08/generator和async函数/">Generator函数和async函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Generator函数可以理解成一个状态机，封装了多个内部状态。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">myGenerator</span></span>() &#123;</span><br><span class="line">	yield <span class="string">'hello'</span>;</span><br><span class="line">	yield <span class="string">'generator'</span>;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var mg = myGenerator();</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"hello"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"generator"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: <span class="string">"ending"</span>, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">console.log(mg.next());// &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>调用Generator函数后并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象（遍历器对象）。<br>因此必须调用遍历器的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或者上一次停下的地方开始执行，知道遇到下一个yield表达式或者return语句。<br>相当于。yield表达式是一个暂时执行的标记，next方法是一个恢复执行的标记。<br>value表示当前内部状态的值，done表示遍历是否结束。可以看到，当到函数执行结束时，done的属性就为true;</p>
<h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p>yield表达式没有返回值，next方法可以带一个参数，该参数会被当作上一个yield表达式的返回值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next() // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12) // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13) // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释：<br>b.next()返回yield (x + 1)的结果，因为x等于5，所以x+1为6；<br>b.next(12)，是将上一个yield的表达式的返回值当作12，因此约等于24，那么y/3就是8.<br>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。这个就需要用到yield* 表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'*foo()'</span>);</span><br><span class="line">    yield 3;</span><br><span class="line">    yield 4;</span><br><span class="line">    console.log(<span class="string">'*foo() finished!!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">bar</span></span>()&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield *foo();</span><br><span class="line">    yield 5;</span><br><span class="line">&#125;</span><br><span class="line">const it=bar();</span><br><span class="line">// 1 2 *foo() 3 4 *foo() finished!! 5</span><br></pre></td></tr></table></figure>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>1.async函数相当于Generator 函数的语法糖。前者比后者多了内置执行器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args)&#123; </span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>spawn 函数是一个自动执行器功能。<br>2.async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。一个函数如果加上async，那么该函数就会返回一个Promise.<br>3.await会暂停当前async函数的执行，等待后面的Promise的计算结果返回以后再继续执行当前的async函数。<br>但是await不是一直等待表达执行的执行结果，之后才会执行后面的代码。await后面的函数会先执行一遍，然后就会跳出整个 async 函数来执行后面js代码。等本轮事件循环执行完又跳回到 async 函数中等待await后面表达式的返回值，如果返回值为非 promise 则继续执行async后面的代码，否则将 promise 加入队列。<br>换句话说，当函数执行的时候，遇到 await 会立即返回一个 pending 状态的promise。<br>4.await等待的不是所有的异步操作，等待的是Promise.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">	await new Promise(resolve =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			console.log(2);</span><br><span class="line">			resolve();// 没有这一行就不会输出3</span><br><span class="line">		&#125;, 1000);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(3);</span><br><span class="line">&#125;)();</span><br><span class="line">// 1 2 3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> myAsync(num) &#123;</span><br><span class="line">	<span class="keyword">if</span> (num &gt; 0) &#123;</span><br><span class="line">		<span class="built_in">return</span> num;// resolve(num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		throw num;// reject(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myAsync(3).<span class="keyword">then</span>(value =&gt; &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myAsync(0).catch(<span class="keyword">function</span> (v) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">// 3 0</span><br></pre></td></tr></table></figure>
<p>async await 本身就是promise+generator的语法糖。下面两个代码等价<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  Promise.resolve(async2()).<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为什么产生"><a href="#为什么产生" class="headerlink" title="为什么产生"></a>为什么产生</h3><p>1.避免回调地狱 ==&gt; Promise ==&gt; async/await<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getData(a =&gt; &#123;</span><br><span class="line">	getMoreData(a, b =&gt; &#123;</span><br><span class="line">		getMoreMoreData(b, c =&gt; &#123;</span><br><span class="line">			console.log(c);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getData()</span><br><span class="line">.<span class="keyword">then</span>(a =&gt; getData(a))</span><br><span class="line">.<span class="keyword">then</span>(b =&gt; getMoreData(b))</span><br><span class="line">.<span class="keyword">then</span>(c =&gt; console.log(c))</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">	const a = await getData();</span><br><span class="line">	const b = await getMoreData(a);</span><br><span class="line">	const c = await getData(b);</span><br><span class="line">	console.log(c);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h2 id="async-await-promise-异步执行顺序"><a href="#async-await-promise-异步执行顺序" class="headerlink" title="async/await , promise 异步执行顺序"></a>async/await , promise 异步执行顺序</h2><p><a href="https://segmentfault.com/a/1190000016329715?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016329715?utm_source=tag-newest</a><br>实际上 await 是一个让出线程的标志（遇到 await 会立即返回一个 pending 状态的promise）。await后面的函数会先执行一遍，然后就会跳出整个 async 函数来执行后面js代码。等本轮事件循环执行完又跳回到 async 函数中等待await后面表达式的返回值，如果返回值为非 promise 则继续执行async后面的代码，否则将 promise 加入队列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async2</span></span>() &#123;</span><br><span class="line">   console.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    console.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"script end"</span>);</span><br><span class="line">//执行结果：</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">settimeout</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">testFunc</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"testFunc..."</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"testFunc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">testAsync</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"testAsync..."</span>);</span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(<span class="string">"hello testAsync"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"test start..."</span>);</span><br><span class="line">    const v1 = await testFunc();</span><br><span class="line">    connsole.log(<span class="string">'hello world.'</span>);</span><br><span class="line">    console.log(v1);</span><br><span class="line">    const v2 = await testAsync();</span><br><span class="line">    console.log(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">var promise = new Promise(resolve =&gt; &#123; </span><br><span class="line">    console.log(<span class="string">"promise start.."</span>);</span><br><span class="line">    resolve(<span class="string">"promise"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">promise.then(val =&gt; console.log(val));</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"test end..."</span>);</span><br><span class="line">//执行结果：</span><br><span class="line"><span class="built_in">test</span> start...</span><br><span class="line">testFunc...</span><br><span class="line">promise start..</span><br><span class="line"><span class="built_in">test</span> end...</span><br><span class="line">hello world.</span><br><span class="line">testFunc</span><br><span class="line">testAsync...</span><br><span class="line">promise</span><br><span class="line">hello testAsync</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/generator和async函数/" data-id="cjtprk6vo0002v4ted35xdhl7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/promise/" class="article-date">
  <time datetime="2019-01-07T01:48:20.573Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/promise/">Promise对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。</p>
<h2 id="promise含义"><a href="#promise含义" class="headerlink" title="promise含义"></a>promise含义</h2><p>1.Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>2.Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就固定，不会再变了，会一直保持这个结果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	console.log(<span class="string">'Promise'</span>);</span><br><span class="line">	<span class="function"><span class="title">if</span></span>() &#123;</span><br><span class="line">		resolve(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reject(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">	// success</span><br><span class="line">	&#125;,error =&gt; &#123;</span><br><span class="line">	// failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1.promise的构造函数接受一个函数作为参数，这个函数有两个参数分别是resolve和reject。而resolve和reject又各自是两个函数。<br>resolve函数，当Promise对象的状态从 pending 变为 resolved，在异步操作成功时调用，并将异步操作的结果作为参数value传递出去。<br>reject函数，当Promise对象的状态从pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误value,作为参数传递出去。<br>2.then方法的参数是两个回调函数：<br>第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数(可选)是Promise对象的状态变为rejected时调用。第二个参数是可选的。<br>then可以采用链式写法。<br>3.Promise 新建后就会立即执行。即回立马输出Promise。<br>4.Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<h2 id="resolve的参数是promise对象时："><a href="#resolve的参数是promise对象时：" class="headerlink" title="resolve的参数是promise对象时："></a>resolve的参数是promise对象时：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure>
<p>执行代码，p1是一个Promise,3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。<br>因此，后面的then语句变成针对P1。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<h2 id="Promise-prototype-finally-："><a href="#Promise-prototype-finally-：" class="headerlink" title="Promise.prototype.finally()："></a>Promise.prototype.finally()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; &#123;&#125;)</span><br><span class="line">.catch(error =&gt; &#123;&#125;)</span><br><span class="line">.finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<h2 id="Promise-all-："><a href="#Promise-all-：" class="headerlink" title="Promise.all()："></a>Promise.all()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>p的状态由p1、p2、p3决定，分为两种情况。<br>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。<br>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
<h2 id="Promise-race-："><a href="#Promise-race-：" class="headerlink" title="Promise.race()："></a>Promise.race()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p =Promise.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h2 id="Promise-resolve-："><a href="#Promise-resolve-：" class="headerlink" title="Promise.resolve()："></a>Promise.resolve()：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象</p>
<p>Promise.resolve(‘foo’); &lt;==&gt; new Promise(resolve =&gt; resolve(‘foo’));</p>
<h2 id="构造函数和原型上的方法"><a href="#构造函数和原型上的方法" class="headerlink" title="构造函数和原型上的方法"></a>构造函数和原型上的方法</h2><p>1.<br>Promise.prototype.then()，Promise.prototype.catch()，Promise.prototype.finally();<br>Promise.all()，Promise.race()，Promise.resolve()，Promise.reject()，Promise.try();</p>
<p>2.在Promise构造函数上实现的all，race，reject，resolve，不能在对象的实例中访问，属于Promise构造函数自己，这样做保证了对象的命名空间整洁。所以这几个函数的调用方式是Promise.all()，Promise.race()，Promise.reject()，Promise.resolve()。</p>
<p>3.在构造函数原型上实现then，catch的方法是为了让Promise构造函数创建的实例共享then，catch方法。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.异步加载图片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loadImageAsync(url) &#123;</span><br><span class="line">	<span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		const image = new Image();</span><br><span class="line">		image.onload = () =&gt; resolve(image); </span><br><span class="line">		image.onerror = () =&gt; reject(new Error(<span class="string">'图片加载失败'</span>));</span><br><span class="line">		image.src = url;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .<span class="keyword">then</span>(2)</span><br><span class="line">  .<span class="keyword">then</span>(Promise.resolve(3))</span><br><span class="line">  .<span class="keyword">then</span>(console.log)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>3.实现一个简单的promise<br><a href="https://segmentfault.com/a/1190000009792439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009792439</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyPromise(fn) &#123;</span><br><span class="line">	this._status = <span class="string">'pending'</span>;</span><br><span class="line">	this._value = undefined;</span><br><span class="line">	this._onResolvedCallback = [];</span><br><span class="line">	this._onRejectCallback = [];</span><br><span class="line">	fn(resolve.bind(this), reject.bind(this));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> resolve(value) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'resolved'</span>;</span><br><span class="line">		this._value = value;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onResolvedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> reject(reason) &#123;</span><br><span class="line">	<span class="keyword">if</span>(this._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">		this._status = <span class="string">'reject'</span>;</span><br><span class="line">		this._value = reason;</span><br><span class="line">		var fn;</span><br><span class="line">		<span class="keyword">while</span>(fn = this._onRejectedCallback.pop()) &#123;</span><br><span class="line">			fn.call(this, value);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="keyword">function</span>(onResolved, onRejected) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	var promise2;</span><br><span class="line">	onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="keyword">function</span>(v) &#123;&#125;;</span><br><span class="line">	onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="keyword">function</span> (r) &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(self._status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">		<span class="built_in">return</span> promise = new MyPromise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				 var x = onResolved(self._value);</span><br><span class="line">				 <span class="keyword">if</span>(x instanceof MyPromise) &#123;</span><br><span class="line">				 	x.then(resolve, reject);</span><br><span class="line">				 &#125;</span><br><span class="line">				 resolve(x);</span><br><span class="line">			&#125; catch(e) &#123;</span><br><span class="line">				reject(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (self._status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">	    <span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">	      try &#123;</span><br><span class="line">	        var x = onRejected(self._value)</span><br><span class="line">	        <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">	          x.then(resolve,reject)</span><br><span class="line">	        &#125;</span><br><span class="line">	      &#125; catch(e) &#123;</span><br><span class="line">	        reject(e)</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(self._status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">  	<span class="built_in">return</span> promise2 = new MyPromise (<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  		self._onResolvedCallback.push(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          var x = onResolved(self._value)</span><br><span class="line">          <span class="keyword">if</span> (x instanceof MyPromise) &#123;</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self._onRejectCallback.push(<span class="keyword">function</span>(reason) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x =onRejected(self._value)</span><br><span class="line">          <span class="keyword">if</span>(x instanceof Promise) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//<span class="built_in">test</span> code</span><br><span class="line">  var myFirstPromise = new MyPromise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          resolve(<span class="string">"成功!"</span>); //代码正常执行！</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  myFirstPromise.then(<span class="keyword">function</span> (successMessage) &#123;</span><br><span class="line">     console.log(<span class="string">"Yay! "</span> + successMessage);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/promise/" data-id="cjtprk6vv0008v4tethzuurg3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/26/BFC/">BFC</a>
          </li>
        
          <li>
            <a href="/2019/03/17/位运算符/">位运算符</a>
          </li>
        
          <li>
            <a href="/2019/02/24/数组遍历方法汇总/">数组遍历</a>
          </li>
        
          <li>
            <a href="/2019/02/22/防抖和节流/">防抖和节流</a>
          </li>
        
          <li>
            <a href="/2019/01/11/渲染机制/">渲染机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>